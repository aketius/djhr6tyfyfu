local objective = Traitormod.RoleManager.Objectives.Objective:new()

objective.Name = "OnAcid"
objective.AmountPoints = 500

function objective:Start(target)
    self.Target = target

    if self.Target == nil then
        return false
    end

    if not self.Character.HasJob("prisondoctor") then
        Traitormod.Debug("OnAcid is only available for medics.")
        return false
    end

    self.TargetName = Traitormod.GetJobString(self.Target) .. " " .. self.Target.Name

    self.Text = string.format("Inject %s with deliriumine.", self.TargetName)

    return true
end

function objective:IsCompleted()
    if self.Target == nil then
        return false
    end

    local aff = self.Target.CharacterHealth.GetAffliction("deliriuminepoisoning", true)

    if aff ~= nil and aff.Strength > 50 then
        return true
    end

    return false
end

function objective:IsFailed()
    if self.Target == nil then
        return false
    end

    if self.Target.IsDead then
        return true
    end

    return false
end

return objective
if CLIENT then return end

Hook.Add("roundStart", "crewmenuRoundStart", function ()
    for key, value in pairs(Client.ClientList) do
        if value.Character ~= nil then
            value.Character.TeamID = CharacterTeamType.FriendlyNPC
        end
    end
end)

Hook.Add("roundEnd", "crewmenuRoundEnd", function ()
    for key, value in pairs(Client.ClientList) do
        if value.Character ~= nil and value.Character.IsHuman and value.Character.TeamID ~= CharacterTeamType.Team2 then
            value.Character.TeamID = CharacterTeamType.Team1
        end
    end
end)

Hook.Add("chatMessage", "crewmenu_chatcommands", function(msg, client)

    if msg == "!alive" then
        if client.Character == nil or client.Character.IsDead == true or bit32.band(client.Permissions, 0x40) == 0x40 then

            local msg = ""
            for key, value in pairs(Character.CharacterList) do

                if value.IsHuman and not value.IsBot then
                    print(value.IsDead)
                    if value.IsDead then
                        msg = msg .. "[DEAD] " .. value.name .. "\n"
                    else
                        msg = msg .. "[ALIVE] " .. value.name .. "\n"
                    end
                end
            end

            Game.SendDirectChatMessage("", msg, nil, 7, client)

            return true
        end

    end
end)
local event = {}

event.Enabled = true
event.Name = "AmmoDelivery"
event.MinRoundTime = 5
event.MinIntensity = 0.6
event.MaxIntensity = 1
event.ChancePerMinute = 0.03
event.OnlyOncePerRound = false

local items = {"coilgunammoboxexplosive", "coilgunammoboxexplosive", "coilgunammoboxexplosive", "railgunshell", "railgunshell", "railgunshell", "railgunshell", "railgunshell"}

event.Start = function ()
    local position = nil

    for key, value in pairs(Submarine.MainSub.GetWaypoints(true)) do
        if value.AssignedJob and value.AssignedJob.Identifier == "securityofficer" then
            position = value.WorldPosition
            break
        end
    end

    if position == nil then
        position = Submarine.MainSub.WorldPosition
    end

    for key, value in pairs(items) do
        Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab(value), position)
    end

    local text = "A delivery of explosive coilgun ammo and railgun shells has been made to the armoury area of the submarine."
    Traitormod.RoundEvents.SendEventMessage(text, "GameModeIcon.sandbox")

    event.End()
end


event.End = function ()

end

return eventlocal role = Traitormod.RoleManager.Roles.Role:new()

role.Name = "Antagonist"
role.IsAntagonist = true

Traitormod.AddCommand("!tc", function(client, args)
    local feedback = Traitormod.Language.CommandNotActive

    local clientRole = Traitormod.RoleManager.GetRole(client.Character)

    if clientRole == nil or client.Character.IsDead then
        feedback = Traitormod.Language.NoTraitor
    elseif not clientRole.TraitorBroadcast then
        feedback = Traitormod.Language.CommandNotActive
    elseif #args > 0 then
        local msg = ""
        for word in args do
            msg = msg .. " " .. word
        end

        for character, role in pairs(Traitormod.RoleManager.RoundRoles) do
            if role.TraitorBroadcast then
                local targetClient = Traitormod.FindClientCharacter(character)

                if targetClient then
                    Game.SendDirectChatMessage("",
                        string.format(Traitormod.Language.TraitorBroadcast, Traitormod.ClientLogName(client), msg), nil,
                        ChatMessageType.Error, targetClient)
                end
            end
        end

        return not clientRole.TraitorBroadcastHearable
    else
        feedback = "Usage: !tc [Message]"
    end

    Game.SendDirectChatMessage("", feedback, nil, Traitormod.Config.ChatMessageType, client)

    return true
end)

Traitormod.AddCommand("!tdm", function(client, args)
    local feedback = ""

    local clientRole = Traitormod.RoleManager.GetRole(client.Character)

    if clientRole == nil or client.Character.IsDead then
        feedback = Traitormod.Language.NoTraitor
    elseif not clientRole.TraitorDm then
        feedback = Traitormod.Language.CommandNotActive
    else
        if #args > 1 then
            local found = Traitormod.FindClient(table.remove(args, 1))
            local msg = ""
            for word in args do
                msg = msg .. " " .. word
            end
            if found then
                Traitormod.SendMessage(found, Traitormod.Language.TraitorDirectMessage .. msg)
                feedback = string.format("[To %s]: %s", Traitormod.ClientLogName(found), msg)
                return true
            else
                feedback = "Name not found."
            end
        else
            feedback = "Usage: !tdm [Name] [Message]"
        end
    end

    Game.SendDirectChatMessage("", feedback, nil, Traitormod.Config.ChatMessageType, client)
    return true
end)


return role
local objective = Traitormod.RoleManager.Objectives.Objective:new()

objective.Name = "Assassinate"
objective.AmountPoints = 600
function objective:Start(target)
    self.Target = target

    if self.Target == nil then return false end

    self.Text = string.format(Traitormod.Language.ObjectiveAssassinate, self.Target.Name)

    return true
end

function objective:IsCompleted()
    return self.Target.IsDead
end

return objective
local event = {}

event.Name = "BeaconPirate"
event.MinRoundTime = 3
event.MaxRoundTime = 20
event.MinIntensity = 0
event.MaxIntensity = 1
event.ChancePerMinute = 0.12
event.OnlyOncePerRound = true

event.AmountPoints = 800
event.AmountPointsPirate = 500

event.Start = function ()
    local beacon = Level.Loaded.BeaconStation

    if beacon == nil then
        return
    end

    for key, value in pairs(Character.CharacterList) do
        if value.IsHuman and value.TeamID == CharacterTeamType.None and value.Submarine == beacon then
            value.SetOriginalTeam(CharacterTeamType.Team2)
            value.UpdateTeam()
        end
    end

    for key, wall in pairs(Structure.WallList) do
        if wall.Submarine == beacon then
            for i = 0, wall.SectionCount, 1 do
                wall.MaxHealth = wall.MaxHealth * 5
                wall.AddDamage(i, -1000000)
            end
        end
    end

    local info = CharacterInfo(Identifier("human"))
    info.Name = "Pirate " .. info.Name
    info.Job = Job(JobPrefab.Get("warden"))

    local character = Character.Create(info, beacon.WorldPosition, info.Name, 0, false, true)
    event.Character = character
    event.Beacon = beacon
    event.EnteredMainSub = false

    character.CanSpeak = true
    character.TeamID = CharacterTeamType.Team2
    character.GiveJobItems(nil)

    local idCard = character.Inventory.GetItemInLimbSlot(InvSlotType.Card)
    if idCard then
        idCard.NonPlayerTeamInteractable = true
        local prop = idCard.SerializableProperties[Identifier("NonPlayerTeamInteractable")]
        Networking.CreateEntityEvent(idCard, Item.ChangePropertyEventData(prop, idCard))
    end

    local headset = character.Inventory.GetItemInLimbSlot(InvSlotType.Headset)
    if headset then
       local wifi = headset.GetComponentString("WifiComponent")
       if wifi then
            wifi.TeamID = CharacterTeamType.FriendlyNPC
       end
    end

    Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.Prefabs["sonarbeacon"], beacon.WorldPosition, nil, nil, function(item)
        item.NonInteractable = true

        Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.Prefabs["batterycell"], item.OwnInventory, nil, nil, function(bat)
            bat.Indestructible = true

            local interface = item.GetComponentString("CustomInterface")

            interface.customInterfaceElementList[1].State = true
            interface.customInterfaceElementList[2].Signal = "Last known pirate position"

            item.CreateServerEvent(interface, interface)
        end)
    end)

    Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("shotgun"), character.Inventory, nil, nil, function (item)
        for i = 1, 6, 1 do
            Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("shotgunshell"), item.OwnInventory)
        end
    end)

    Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("smg"), character.Inventory, nil, nil, function (item)
        Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("smgmagazinedepletedfuel"), item.OwnInventory)
    end)

    Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("smgmagazine"), character.Inventory)
    Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("smgmagazine"), character.Inventory)

    for i = 1, 12, 1 do
        Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("shotgunshell"), character.Inventory)
    end

    for i = 1, 4, 1 do
        Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("antibiotics"), character.Inventory)
    end
    local toolbelt = character.Inventory.GetItemInLimbSlot(InvSlotType.Bag)
    Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("antidama1"), toolbelt.OwnInventory)
    Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("antidama1"), toolbelt.OwnInventory)
    for i = 1, 6, 1 do
        Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("antibleeding1"), toolbelt.OwnInventory)
    end
    Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("alienblood"), toolbelt.OwnInventory)
    Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("fuelrod"), toolbelt.OwnInventory)
    Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("underwaterscooter"), toolbelt.OwnInventory, nil, nil, function (item)
        Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("batterycell"), item.OwnInventory)
    end)
    Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("handheldsonar"), toolbelt.OwnInventory, nil, nil, function (item)
        Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("batterycell"), item.OwnInventory)
    end)

    local oldClothes = character.Inventory.GetItemInLimbSlot(InvSlotType.InnerClothes)
    oldClothes.Drop()
    Entity.Spawner.AddEntityToRemoveQueue(oldClothes)

    Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("pirateclothes"), character.Inventory, nil, nil, function (item)
        character.Inventory.TryPutItem(item, character.Inventory.FindLimbSlot(InvSlotType.InnerClothes), true, false, character)
    end)

    Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("pucs"), character.Inventory, nil, nil, function (item)
        Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("combatstimulantsyringe"), item.OwnInventory)
        Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("oxygenitetank"), item.OwnInventory)
    end)

    event.ItemReward = character.Inventory.GetItemInLimbSlot(InvSlotType.Card)

    local text = "There have been reports about a notorious pirate with a PUCS suit terrorizing these waters, the pirate was detected recently inside a beacon station - eliminate the pirate to claim a reward of " .. event.AmountPoints .. " points for the entire crew."
    Traitormod.RoundEvents.SendEventMessage(text, "CrewWalletIconLarge")

    Traitormod.GhostRoles.Ask("Beacon Pirate", function (client)
        Traitormod.LostLivesThisRound[client.SteamID] = false
        client.SetClientCharacter(character)

        Traitormod.SendMessageCharacter(character, "You are a pirate! Protect the beacon station from any filthy coalitions trying to get what is yours! \n\nSurviving inside the beacon station until the end of the round will grant you " .. event.AmountPointsPirate .." points.", "InfoFrameTabButton.Mission")
    end, character)

    Hook.Add("think", "BeaconPirate.Think", function ()
        if character.IsDead then
            event.End()
        end

        if character.Submarine == Submarine.MainSub and not event.EnteredMainSub then
            event.EnteredMainSub = true
            Traitormod.RoundEvents.SendEventMessage("Attention! A dangerous PUCS pirate has been detected inside the main submarine!")
        end
    end)
end


event.End = function (isEndRound)
    Hook.Remove("think", "BeaconPirate.Think")

    if isEndRound then
        if event.Character and not event.Character.IsDead and event.Character.Submarine == event.Beacon then
            local client = Traitormod.FindClientCharacter(event.Character)
            if client then
                Traitormod.AwardPoints(client, event.AmountPointsPirate)
                Traitormod.SendMessage(client, "You have received " .. event.AmountPointsPirate .. " points.", "InfoFrameTabButton.Mission")
            end
        end

        return
    end

    local text = "The PUCS pirate has been killed, the crew has received a reward of " .. event.AmountPoints .. " points."

    Traitormod.RoundEvents.SendEventMessage(text, "CrewWalletIconLarge")

    for _, client in pairs(Client.ClientList) do
        if client.Character and not client.Character.IsDead and client.Character.TeamID == CharacterTeamType.FriendlyNPC then
            Traitormod.AwardPoints(client, event.AmountPoints)
            Traitormod.SendMessage(client, "You have received " .. event.AmountPoints .. " points.", "InfoFrameTabButton.Mission")
        end
    end
end

return eventlocal role = Traitormod.RoleManager.Roles.Role:new()
role.Name = "Clown"
role.Antagonist = true


function role:Start()

    

    local text = self:Greet()
    local client = Traitormod.FindClientCharacter(self.Character)
    if client then
        Traitormod.SendTraitorMessageBox(client, text)
        Traitormod.UpdateVanillaTraitor(client, true, text)
    end
end


function role:End(roundEnd)

end

---@return string objectives
function role:ObjectivesToString()
    local objs = Traitormod.StringBuilder:new()

    for _, objective in pairs(self.Objectives) do

        if objective:IsCompleted() then
            objs:append(" > ", objective.Text, Traitormod.Language.Completed)
        else
            objs:append(" > ", objective.Text, string.format(Traitormod.Language.Points, objective.AmountPoints))
        end
    end
    if #objs == 0 then
        objs(" > No objectives yet... Stay futile.")
    end

    return objs:concat("\n")
end

function role:Greet()
    local objectives = self:ObjectivesToString()

    local sb = Traitormod.StringBuilder:new()
    sb("You are now part of the Children of The Honkmother.\nComplete the objectives given to you to prove yourself worthy.\n\n")
    sb("Your objectives are:\n")
    sb(objectives)
    sb("\n\n")

    return sb:concat()
end

function role:OtherGreet()
    return ""
end

function role:FilterTarget(objective, character)
    if not self.SelectBotsAsTargets and character.IsBot then return false end

    if objective.Name == "Assassinate" and self.SelectUniqueTargets then
        for key, value in pairs(Traitormod.RoleManager.FindCharactersByRole("Traitor")) do
            local role = Traitormod.RoleManager.GetRole(value)

            for key, obj in pairs(role.Objectives) do
                if obj.Name == "Assassinate" and obj.Target == character then
                    return false
                end
            end
        end
    end

    if character.TeamID ~= CharacterTeamType.Team1 and not self.SelectPiratesAsTargets then
        return false
    end

    return Traitormod.RoleManager.Roles.Role.FilterTarget(self, objective, character)
end


return role
local objective = Traitormod.RoleManager.Objectives.Objective:new()

objective.Name = "OnAcid"
objective.AmountPoints = 500

function objective:Start(target)
    self.Target = target

    if self.Target == nil then
        return false
    end

    if not self.Character.HasJob("prisondoctor") then
        Traitormod.Debug("OnAcid is only available for medics.")
        return false
    end

    self.TargetName = Traitormod.GetJobString(self.Target) .. " " .. self.Target.Name

    self.Text = string.format("Inject %s with deliriumine.", self.TargetName)

    return true
end

function objective:IsCompleted()
    if self.Target == nil then
        return false
    end

    local aff = self.Target.CharacterHealth.GetAffliction("deliriuminepoisoning", true)

    if aff ~= nil and aff.Strength > 50 then
        return true
    end

    return false
end

function objective:IsFailed()
    if self.Target == nil then
        return false
    end

    if self.Target.IsDead then
        return true
    end

    return false
end

return objective
if CLIENT then return end

Hook.Add("roundStart", "crewmenuRoundStart", function ()
    for key, value in pairs(Client.ClientList) do
        if value.Character ~= nil then
            value.Character.TeamID = CharacterTeamType.FriendlyNPC
        end
    end
end)

Hook.Add("roundEnd", "crewmenuRoundEnd", function ()
    for key, value in pairs(Client.ClientList) do
        if value.Character ~= nil and value.Character.IsHuman and value.Character.TeamID ~= CharacterTeamType.Team2 then
            value.Character.TeamID = CharacterTeamType.Team1
        end
    end
end)

Hook.Add("chatMessage", "crewmenu_chatcommands", function(msg, client)

    if msg == "!alive" then
        if client.Character == nil or client.Character.IsDead == true or bit32.band(client.Permissions, 0x40) == 0x40 then

            local msg = ""
            for key, value in pairs(Character.CharacterList) do

                if value.IsHuman and not value.IsBot then
                    print(value.IsDead)
                    if value.IsDead then
                        msg = msg .. "[DEAD] " .. value.name .. "\n"
                    else
                        msg = msg .. "[ALIVE] " .. value.name .. "\n"
                    end
                end
            end

            Game.SendDirectChatMessage("", msg, nil, 7, client)

            return true
        end

    end
end)
local event = {}

event.Enabled = true
event.Name = "AmmoDelivery"
event.MinRoundTime = 5
event.MinIntensity = 0.6
event.MaxIntensity = 1
event.ChancePerMinute = 0.03
event.OnlyOncePerRound = false

local items = {"coilgunammoboxexplosive", "coilgunammoboxexplosive", "coilgunammoboxexplosive", "railgunshell", "railgunshell", "railgunshell", "railgunshell", "railgunshell"}

event.Start = function ()
    local position = nil

    for key, value in pairs(Submarine.MainSub.GetWaypoints(true)) do
        if value.AssignedJob and value.AssignedJob.Identifier == "securityofficer" then
            position = value.WorldPosition
            break
        end
    end

    if position == nil then
        position = Submarine.MainSub.WorldPosition
    end

    for key, value in pairs(items) do
        Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab(value), position)
    end

    local text = "A delivery of explosive coilgun ammo and railgun shells has been made to the armoury area of the submarine."
    Traitormod.RoundEvents.SendEventMessage(text, "GameModeIcon.sandbox")

    event.End()
end


event.End = function ()

end

return eventlocal role = Traitormod.RoleManager.Roles.Role:new()

role.Name = "Antagonist"
role.IsAntagonist = true

Traitormod.AddCommand("!tc", function(client, args)
    local feedback = Traitormod.Language.CommandNotActive

    local clientRole = Traitormod.RoleManager.GetRole(client.Character)

    if clientRole == nil or client.Character.IsDead then
        feedback = Traitormod.Language.NoTraitor
    elseif not clientRole.TraitorBroadcast then
        feedback = Traitormod.Language.CommandNotActive
    elseif #args > 0 then
        local msg = ""
        for word in args do
            msg = msg .. " " .. word
        end

        for character, role in pairs(Traitormod.RoleManager.RoundRoles) do
            if role.TraitorBroadcast then
                local targetClient = Traitormod.FindClientCharacter(character)

                if targetClient then
                    Game.SendDirectChatMessage("",
                        string.format(Traitormod.Language.TraitorBroadcast, Traitormod.ClientLogName(client), msg), nil,
                        ChatMessageType.Error, targetClient)
                end
            end
        end

        return not clientRole.TraitorBroadcastHearable
    else
        feedback = "Usage: !tc [Message]"
    end

    Game.SendDirectChatMessage("", feedback, nil, Traitormod.Config.ChatMessageType, client)

    return true
end)

Traitormod.AddCommand("!tdm", function(client, args)
    local feedback = ""

    local clientRole = Traitormod.RoleManager.GetRole(client.Character)

    if clientRole == nil or client.Character.IsDead then
        feedback = Traitormod.Language.NoTraitor
    elseif not clientRole.TraitorDm then
        feedback = Traitormod.Language.CommandNotActive
    else
        if #args > 1 then
            local found = Traitormod.FindClient(table.remove(args, 1))
            local msg = ""
            for word in args do
                msg = msg .. " " .. word
            end
            if found then
                Traitormod.SendMessage(found, Traitormod.Language.TraitorDirectMessage .. msg)
                feedback = string.format("[To %s]: %s", Traitormod.ClientLogName(found), msg)
                return true
            else
                feedback = "Name not found."
            end
        else
            feedback = "Usage: !tdm [Name] [Message]"
        end
    end

    Game.SendDirectChatMessage("", feedback, nil, Traitormod.Config.ChatMessageType, client)
    return true
end)


return role
local objective = Traitormod.RoleManager.Objectives.Objective:new()

objective.Name = "Assassinate"
objective.AmountPoints = 600
function objective:Start(target)
    self.Target = target

    if self.Target == nil then return false end

    self.Text = string.format(Traitormod.Language.ObjectiveAssassinate, self.Target.Name)

    return true
end

function objective:IsCompleted()
    return self.Target.IsDead
end

return objective
local event = {}

event.Name = "BeaconPirate"
event.MinRoundTime = 3
event.MaxRoundTime = 20
event.MinIntensity = 0
event.MaxIntensity = 1
event.ChancePerMinute = 0.12
event.OnlyOncePerRound = true

event.AmountPoints = 800
event.AmountPointsPirate = 500

event.Start = function ()
    local beacon = Level.Loaded.BeaconStation

    if beacon == nil then
        return
    end

    for key, value in pairs(Character.CharacterList) do
        if value.IsHuman and value.TeamID == CharacterTeamType.None and value.Submarine == beacon then
            value.SetOriginalTeam(CharacterTeamType.Team2)
            value.UpdateTeam()
        end
    end

    for key, wall in pairs(Structure.WallList) do
        if wall.Submarine == beacon then
            for i = 0, wall.SectionCount, 1 do
                wall.MaxHealth = wall.MaxHealth * 5
                wall.AddDamage(i, -1000000)
            end
        end
    end

    local info = CharacterInfo(Identifier("human"))
    info.Name = "Pirate " .. info.Name
    info.Job = Job(JobPrefab.Get("warden"))

    local character = Character.Create(info, beacon.WorldPosition, info.Name, 0, false, true)
    event.Character = character
    event.Beacon = beacon
    event.EnteredMainSub = false

    character.CanSpeak = true
    character.TeamID = CharacterTeamType.Team2
    character.GiveJobItems(nil)

    local idCard = character.Inventory.GetItemInLimbSlot(InvSlotType.Card)
    if idCard then
        idCard.NonPlayerTeamInteractable = true
        local prop = idCard.SerializableProperties[Identifier("NonPlayerTeamInteractable")]
        Networking.CreateEntityEvent(idCard, Item.ChangePropertyEventData(prop, idCard))
    end

    local headset = character.Inventory.GetItemInLimbSlot(InvSlotType.Headset)
    if headset then
       local wifi = headset.GetComponentString("WifiComponent")
       if wifi then
            wifi.TeamID = CharacterTeamType.FriendlyNPC
       end
    end

    Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.Prefabs["sonarbeacon"], beacon.WorldPosition, nil, nil, function(item)
        item.NonInteractable = true

        Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.Prefabs["batterycell"], item.OwnInventory, nil, nil, function(bat)
            bat.Indestructible = true

            local interface = item.GetComponentString("CustomInterface")

            interface.customInterfaceElementList[1].State = true
            interface.customInterfaceElementList[2].Signal = "Last known pirate position"

            item.CreateServerEvent(interface, interface)
        end)
    end)

    Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("shotgun"), character.Inventory, nil, nil, function (item)
        for i = 1, 6, 1 do
            Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("shotgunshell"), item.OwnInventory)
        end
    end)

    Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("smg"), character.Inventory, nil, nil, function (item)
        Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("smgmagazinedepletedfuel"), item.OwnInventory)
    end)

    Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("smgmagazine"), character.Inventory)
    Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("smgmagazine"), character.Inventory)

    for i = 1, 12, 1 do
        Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("shotgunshell"), character.Inventory)
    end

    for i = 1, 4, 1 do
        Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("antibiotics"), character.Inventory)
    end
    local toolbelt = character.Inventory.GetItemInLimbSlot(InvSlotType.Bag)
    Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("antidama1"), toolbelt.OwnInventory)
    Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("antidama1"), toolbelt.OwnInventory)
    for i = 1, 6, 1 do
        Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("antibleeding1"), toolbelt.OwnInventory)
    end
    Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("alienblood"), toolbelt.OwnInventory)
    Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("fuelrod"), toolbelt.OwnInventory)
    Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("underwaterscooter"), toolbelt.OwnInventory, nil, nil, function (item)
        Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("batterycell"), item.OwnInventory)
    end)
    Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("handheldsonar"), toolbelt.OwnInventory, nil, nil, function (item)
        Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("batterycell"), item.OwnInventory)
    end)

    local oldClothes = character.Inventory.GetItemInLimbSlot(InvSlotType.InnerClothes)
    oldClothes.Drop()
    Entity.Spawner.AddEntityToRemoveQueue(oldClothes)

    Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("pirateclothes"), character.Inventory, nil, nil, function (item)
        character.Inventory.TryPutItem(item, character.Inventory.FindLimbSlot(InvSlotType.InnerClothes), true, false, character)
    end)

    Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("pucs"), character.Inventory, nil, nil, function (item)
        Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("combatstimulantsyringe"), item.OwnInventory)
        Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("oxygenitetank"), item.OwnInventory)
    end)

    event.ItemReward = character.Inventory.GetItemInLimbSlot(InvSlotType.Card)

    local text = "There have been reports about a notorious pirate with a PUCS suit terrorizing these waters, the pirate was detected recently inside a beacon station - eliminate the pirate to claim a reward of " .. event.AmountPoints .. " points for the entire crew."
    Traitormod.RoundEvents.SendEventMessage(text, "CrewWalletIconLarge")

    Traitormod.GhostRoles.Ask("Beacon Pirate", function (client)
        Traitormod.LostLivesThisRound[client.SteamID] = false
        client.SetClientCharacter(character)

        Traitormod.SendMessageCharacter(character, "You are a pirate! Protect the beacon station from any filthy coalitions trying to get what is yours! \n\nSurviving inside the beacon station until the end of the round will grant you " .. event.AmountPointsPirate .." points.", "InfoFrameTabButton.Mission")
    end, character)

    Hook.Add("think", "BeaconPirate.Think", function ()
        if character.IsDead then
            event.End()
        end

        if character.Submarine == Submarine.MainSub and not event.EnteredMainSub then
            event.EnteredMainSub = true
            Traitormod.RoundEvents.SendEventMessage("Attention! A dangerous PUCS pirate has been detected inside the main submarine!")
        end
    end)
end


event.End = function (isEndRound)
    Hook.Remove("think", "BeaconPirate.Think")

    if isEndRound then
        if event.Character and not event.Character.IsDead and event.Character.Submarine == event.Beacon then
            local client = Traitormod.FindClientCharacter(event.Character)
            if client then
                Traitormod.AwardPoints(client, event.AmountPointsPirate)
                Traitormod.SendMessage(client, "You have received " .. event.AmountPointsPirate .. " points.", "InfoFrameTabButton.Mission")
            end
        end

        return
    end

    local text = "The PUCS pirate has been killed, the crew has received a reward of " .. event.AmountPoints .. " points."

    Traitormod.RoundEvents.SendEventMessage(text, "CrewWalletIconLarge")

    for _, client in pairs(Client.ClientList) do
        if client.Character and not client.Character.IsDead and client.Character.TeamID == CharacterTeamType.FriendlyNPC then
            Traitormod.AwardPoints(client, event.AmountPoints)
            Traitormod.SendMessage(client, "You have received " .. event.AmountPoints .. " points.", "InfoFrameTabButton.Mission")
        end
    end
end

return eventlocal role = Traitormod.RoleManager.Roles.Role:new()
role.Name = "Clown"
role.Antagonist = true


function role:Start()

    

    local text = self:Greet()
    local client = Traitormod.FindClientCharacter(self.Character)
    if client then
        Traitormod.SendTraitorMessageBox(client, text)
        Traitormod.UpdateVanillaTraitor(client, true, text)
    end
end


function role:End(roundEnd)

end

---@return string objectives
function role:ObjectivesToString()
    local objs = Traitormod.StringBuilder:new()

    for _, objective in pairs(self.Objectives) do

        if objective:IsCompleted() then
            objs:append(" > ", objective.Text, Traitormod.Language.Completed)
        else
            objs:append(" > ", objective.Text, string.format(Traitormod.Language.Points, objective.AmountPoints))
        end
    end
    if #objs == 0 then
        objs(" > No objectives yet... Stay futile.")
    end

    return objs:concat("\n")
end

function role:Greet()
    local objectives = self:ObjectivesToString()

    local sb = Traitormod.StringBuilder:new()
    sb("You are now part of the Children of The Honkmother.\nComplete the objectives given to you to prove yourself worthy.\n\n")
    sb("Your objectives are:\n")
    sb(objectives)
    sb("\n\n")

    return sb:concat()
end

function role:OtherGreet()
    return ""
end

function role:FilterTarget(objective, character)
    if not self.SelectBotsAsTargets and character.IsBot then return false end

    if objective.Name == "Assassinate" and self.SelectUniqueTargets then
        for key, value in pairs(Traitormod.RoleManager.FindCharactersByRole("Traitor")) do
            local role = Traitormod.RoleManager.GetRole(value)

            for key, obj in pairs(role.Objectives) do
                if obj.Name == "Assassinate" and obj.Target == character then
                    return false
                end
            end
        end
    end

    if character.TeamID ~= CharacterTeamType.Team1 and not self.SelectPiratesAsTargets then
        return false
    end

    return Traitormod.RoleManager.Roles.Role.FilterTarget(self, objective, character)
end


return role
local objective = Traitormod.RoleManager.Objectives.Objective:new()

objective.Name = "OnAcid"
objective.AmountPoints = 500

function objective:Start(target)
    self.Target = target

    if self.Target == nil then
        return false
    end

    if not self.C----- USER COMMANDS -----
Traitormod.AddCommand("!help", function (client, args)
    Traitormod.SendMessage(client, Traitormod.Language.Help)

    return true
end)

Traitormod.AddCommand("!helpadmin", function (client, args)
    Traitormod.SendMessage(client, Traitormod.Language.HelpAdmin)

    return true
end)

Traitormod.AddCommand("!helptraitor", function (client, args)
    Traitormod.SendMessage(client, Traitormod.Language.HelpTraitor)

    return true
end)

Traitormod.AddCommand("!version", function (client, args)
    Traitormod.SendMessage(client, "Running Evil Factory's Traitor Mod v" .. Traitormod.VERSION)

    return true
end)

--[[
Traitormod.AddCommand({"!announce"}, function (client, args)
    if client.Character == nil then
        Traitormod.SendMessage(client, "You aren't alive.")
    return true end
    
    for item in client.Character.Inventory.AllItems do

        if #args < 1 then
            Traitormod.SendMessage(client, "Incorrect amount of arguments. usage: !announce [msg] - If you need to announce something with more than one word, surround it in quotations.")
    
            return true
        end

        local text = table.remove(args, 1)

        if item.Prefab.Identifier == "idcard" and item.GetComponentString("IdCard").OwnerJobId == "warden" then
            if client.Character == nil or client.Character.IsDead then
                Traitormod.SendMessage(client, "You aren't alive.")
            return true end

            Traitormod.RoundEvents.SendEventMessage("Warden's Announcement: "..text, "GameModeIcon.sandbox", Color.LightBlue)

            return true
        else
            Traitormod.SendMessage(client, "You do not have the Warden's ID.")
    
            return true
        end
    end
end)
--]]

Traitormod.AddCommand("!announce", function(client, args)
    local feedback = nil

    if client.Character == nil or client.Character.IsDead then
        feedback = "You're dead."
        Game.SendDirectChatMessage("", feedback, nil, Traitormod.Config.ChatMessageType, client)
    return true end

    for item in client.Character.Inventory.AllItems do
        if #args > 0 and item.Prefab.Identifier == "idcard" and item.GetComponentString("IdCard").OwnerJobId == "warden" then
            local msg = ""
            for word in args do
                msg = msg .. " " .. word
            end

            Traitormod.RoundEvents.SendEventMessage("Warden's Announcement: "..msg, "GameModeIcon.sandbox", Color.LightBlue)
            return true
        else
            feedback = "You don't have the warden's ID."
            Game.SendDirectChatMessage("", feedback, nil, Traitormod.Config.ChatMessageType, client)
            return true
        end
    end
end)

Traitormod.AddCommand({"!role", "!traitor"}, function (client, args)
    if client.Character == nil or client.Character.IsDead then
        Traitormod.SendMessage(client, "You need to be alive to use this command.")
        return true
    end

    local role = Traitormod.RoleManager.GetRole(client.Character)
    if role == nil then
        Traitormod.SendMessage(client, "You have no special role.")
    else
        Traitormod.SendMessage(client, role:Greet())
    end

    return true
end)

Traitormod.AddCommand({"!roles", "!traitors"}, function (client, args)
    if not client.HasPermission(ClientPermissions.ConsoleCommands) then return end

    local roles = {}

    for character, role in pairs(Traitormod.RoleManager.RoundRoles) do
        if not roles[role.Name] then
            roles[role.Name] = {}
        end

        table.insert(roles[role.Name], character.Name)
    end

    local message = ""

    for roleName, r in pairs(roles) do
        message = message .. roleName .. ": "
        for _, name in pairs(r) do
            message = message .. "\"" .. name .. "\" "
        end
        message = message .. "\n\n"
    end

    if message == "" then message = "None." end

    Traitormod.SendMessage(client, message)

    return true
end)

Traitormod.AddCommand("!traitoralive", function (client, args)
    if not client.HasPermission(ClientPermissions.ConsoleCommands) then return end

    for _, character in pairs(Traitormod.RoleManager.FindAntagonists()) do
        if not character.IsDead then
            Traitormod.SendMessage(client, Traitormod.Language.TraitorsAlive)
            return true
        end
    end

    Traitormod.SendMessage(client, Traitormod.Language.AllTraitorsDead)
    return true
end)

Traitormod.AddCommand("!toggletraitor", function (client, args)
    local text = Traitormod.Language.CommandNotActive

    if Traitormod.Config.OptionalTraitors then
        local toggle = false
        if #args > 0 then
            toggle = string.lower(args[1]) == "on"
        else
            toggle = Traitormod.GetData(client, "NonTraitor") == true
        end
    
        if toggle then
            text = Traitormod.Language.TraitorOn
        else
            text = Traitormod.Language.TraitorOff
        end
        Traitormod.SetData(client, "NonTraitor", not toggle)
        Traitormod.SaveData() -- move this to player disconnect someday...
        
        Traitormod.Log(Traitormod.ClientLogName(client) .. " can become traitor: " .. tostring(toggle))
    end

    Traitormod.SendMessage(client, text)

    return true
end)

Traitormod.AddCommand({"!point", "!points"}, function (client, args)
    Traitormod.SendMessage(client, Traitormod.GetDataInfo(client, true))

    return true
end)

Traitormod.AddCommand("!info", function (client, args)
    Traitormod.SendWelcome(client)
    
    return true
end)

Traitormod.AddCommand({"!suicide", "!kill", "!death"}, function (client, args)
    if client.Character == nil or client.Character.IsDead then
        Traitormod.SendMessage(client, "You are already dead!")
        return true
    end

    if client.Character.IsHuman then
        local item = client.Character.Inventory.GetItemInLimbSlot(InvSlotType.RightHand)
        if item ~= nil and item.Prefab.Identifier == "handcuffs" then
            Traitormod.SendMessage(client, "You cant use this command while handcuffed.")
            return true
        end

        if client.Character.IsKnockedDown then
            Traitormod.SendMessage(client, "You cant this command while knocked down.")
            return true
        end
    end

    if Traitormod.GhostRoles.ReturnGhostRole(client.Character) then
        client.SetClientCharacter(nil)
    else
        client.Character.Kill(CauseOfDeathType.Unknown)
    end
end)

----- ADMIN COMMANDS -----
Traitormod.AddCommand("!alive", function (client, args)
    if not (client.Character == nil or client.Character.IsDead) and not client.HasPermission(ClientPermissions.ConsoleCommands) then return end

    if not Game.RoundStarted or Traitormod.SelectedGamemode == nil then
        Traitormod.SendMessage(client, Traitormod.Language.RoundNotStarted)

        return true
    end

    local msg = ""
    for index, value in pairs(Character.CharacterList) do
        if value.IsHuman and not value.IsBot then
            if value.IsDead then
                msg = msg .. value.Name .. " ---- " .. Traitormod.Language.Dead .. "\n"
            else
                msg = msg .. value.Name .. " ++++ " .. Traitormod.Language.Alive .. "\n"
            end
        end
    end

    Traitormod.SendMessage(client, msg)

    return true
end)

Traitormod.AddCommand("!roundinfo", function (client, args)
    if not client.HasPermission(ClientPermissions.ConsoleCommands) then return end

    if Game.RoundStarted and Traitormod.SelectedGamemode and Traitormod.SelectedGamemode.RoundSummary then
        local summary = Traitormod.SelectedGamemode:RoundSummary()
        Traitormod.SendMessage(client, summary)
    elseif Game.RoundStarted and not Traitormod.SelectedGamemode then
        Traitormod.SendMessage(client, "Gamemode: None")
    elseif Traitormod.LastRoundSummary ~= nil then
        Traitormod.SendMessage(client, Traitormod.LastRoundSummary)
    else
        Traitormod.SendMessage(client, Traitormod.Language.RoundNotStarted)
    end

    return true
end)

Traitormod.AddCommand({"!allpoint", "!allpoints"}, function (client, args)
    if not client.HasPermission(ClientPermissions.ConsoleCommands) then return end
    
    local messageToSend = ""

    for index, value in pairs(Client.ClientList) do
        messageToSend = messageToSend .. "\n" .. value.Name .. ": " .. math.floor(Traitormod.GetData(value, "Points") or 0) .. " Points - " .. math.floor(Traitormod.GetData(value, "Weight") or 0) .. " Weight"
    end

    Traitormod.SendMessage(client, messageToSend)

    return true
end)

Traitormod.AddCommand({"!addpoint", "!addpoints"}, function (client, args)
    if not client.HasPermission(ClientPermissions.ConsoleCommands) then
        Traitormod.SendMessage(client, "You do not have permissions to add points.")
        return
    end
    
    if #args < 2 then
        Traitormod.SendMessage(client, "Incorrect amount of arguments. usage: !addpoint \"Client Name\" 500")

        return true
    end

    local name = table.remove(args, 1)
    local amount = tonumber(table.remove(args, 1))

    if amount == nil or amount ~= amount then
        Traitormod.SendMessage(client, "Invalid number value.")
        return true
    end

    if name == "all" then
        for index, value in pairs(Client.ClientList) do
            Traitormod.AddData(value, "Points", amount)
        end

        Traitormod.SendMessage(client, string.format(Traitormod.Language.PointsAwarded, amount), "InfoFrameTabButton.Mission")

        local msg = string.format("Admin added %s points to everyone.", amount)
        Traitormod.SendMessageEveryone(msg)
        msg = Traitormod.ClientLogName(client) .. ": " .. msg
        Traitormod.Log(msg)

        return true
    end

    local found = Traitormod.FindClient(name)

    if found == nil then
        Traitormod.SendMessage(client, "Couldn't find a client with name / steamID " .. name)
        return true
    end

    Traitormod.AddData(found, "Points", amount)

    Traitormod.SendMessage(client, string.format(Traitormod.Language.PointsAwarded, amount), "InfoFrameTabButton.Mission")

    local msg = string.format("Admin added %s points to %s.", amount, Traitormod.ClientLogName(found))
    Traitormod.SendMessageEveryone(msg)
    msg = Traitormod.ClientLogName(client) .. ": " .. msg
    Traitormod.Log(msg)

    return true
end)

Traitormod.AddCommand({"!addlife", "!addlive", "!addlifes", "!addlives"}, function (client, args)
    if not client.HasPermission(ClientPermissions.ConsoleCommands) then return end

    if #args < 1 then
        Traitormod.SendMessage(client, "Incorrect amount of arguments. usage: !addlife \"Client Name\" 1")

        return true
    end

    local name = table.remove(args, 1)

    local amount = 1
    if #args > 0 then
        amount = tonumber(table.remove(args, 1))
    end

    if amount == nil or amount ~= amount then
        Traitormod.SendMessage(client, "Invalid number value.")
        return true
    end

    local gainLifeClients = {}
    if string.lower(name) == "all" then
        gainLifeClients = Client.ClientList
    else
        local found = Traitormod.FindClient(name)

        if found == nil then
            Traitormod.SendMessage(client, "Couldn't find a client with name / steamID " .. name)
            return true
        end
        table.insert(gainLifeClients, found)
    end

    for lifeClient in gainLifeClients do
        local lifeMsg, lifeIcon = Traitormod.AdjustLives(lifeClient, amount)
        local msg = string.format("Admin added %s lives to %s.", amount, Traitormod.ClientLogName(lifeClient))

        if lifeMsg then
            Traitormod.SendMessage(lifeClient, lifeMsg, lifeIcon)
            Traitormod.SendMessageEveryone(msg)
        else
            Game.SendDirectChatMessage("", Traitormod.ClientLogName(lifeClient) .. " already has maximum lives.", nil, Traitormod.Config.Error, client)
        end
    end

    return true
end)

local voidPos = {}

Traitormod.AddCommand("!void", function (client, args)
    if not client.HasPermission(ClientPermissions.ConsoleCommands) then return end

    local target = Traitormod.FindClient(args[1])

    if not target then
        Traitormod.SendMessage(client, "Couldn't find a client with specified name / steamID")
        return true
    end

    if target.Character == nil or target.Character.IsDead then
        Traitormod.SendMessage(client, "Client's character is dead or non-existent.")
        return true
    end

    voidPos[target.Character] = target.Character.WorldPosition
    target.Character.TeleportTo(Vector2(0, Level.Loaded.Size.Y + 100000))
    target.Character.GodMode = true

    Traitormod.SendMessage(client, "Sent the character to the void.")

    return true
end)

Traitormod.AddCommand("!spawn", function (client, args)
    if not client.HasPermission(ClientPermissions.ConsoleCommands) then return end

    local spawnClient = client

    if #args > 0 then
        -- if client name is given, revive related character
        local name = table.remove(args, 1)
        -- find character by client name
        for player in Client.ClientList do
            if player.Name == name or player.SteamID == name then
                spawnClient = player
            end
        end
    end

    if spawnClient.Character == nil or spawnClient.Character.IsDead then
        MidRoundSpawn.TryCreateClientCharacter(spawnClient)
        Game.SendDirectChatMessage("", "Character of ".. Traitormod.ClientLogName(spawnClient) .. " successfully spawned.", nil, ChatMessageType.Server, client)
    else
        Game.SendDirectChatMessage("", "Character of " .. Traitormod.ClientLogName(spawnClient) .. " is alive.", nil, ChatMessageType.Error, client)
    end

    return true
end)

Traitormod.AddCommand("!unvoid", function (client, args)
    if not client.HasPermission(ClientPermissions.ConsoleCommands) then return end

    local target = Traitormod.FindClient(args[1])

    if not target then
        Traitormod.SendMessage(client, "Couldn't find a client with specified name / steamID")
        return true
    end

    if target.Character == nil or target.Character.IsDead then
        Traitormod.SendMessage(client, "Client's character is dead or non-existent.")
        return true
    end

    target.Character.TeleportTo(voidPos[target.Character])
    target.Character.GodMode = false
    voidPos[target.Character] = nil
    
    Traitormod.SendMessage(client, "Remove character from the void.")

    return true
end)

Traitormod.AddCommand("!revive", function (client, args)
    if not client.HasPermission(ClientPermissions.ConsoleCommands) then return end

    local reviveClient = client

    if #args > 0 then
        -- if client name is given, revive related character
        local name = table.remove(args, 1)
        -- find character by client name
        for player in Client.ClientList do
            if player.Name == name or player.SteamID == name then
                reviveClient = player
            end
        end
    end

    if reviveClient.Character and reviveClient.Character.IsDead then
        reviveClient.Character.Revive()
        Timer.Wait(function ()
            reviveClient.SetClientCharacter(reviveClient.Character)
        end, 1500)
        local liveMsg, liveIcon = Traitormod.AdjustLives(reviveClient, 1)

        if liveMsg then
            Traitormod.SendMessage(reviveClient, liveMsg, liveIcon)
        end

        Game.SendDirectChatMessage("", "Character of " .. Traitormod.ClientLogName(reviveClient) .. " revived and given back 1 life.", nil, ChatMessageType.Error, client)
        Traitormod.SendMessageEveryone(string.format("Admin revived %s", Traitormod.ClientLogName(reviveClient)))

    elseif reviveClient.Character then
        Game.SendDirectChatMessage("", "Character of " .. Traitormod.ClientLogName(reviveClient) .. " is not dead.", nil, ChatMessageType.Error, client)
    else
        Game.SendDirectChatMessage("", "Character of " .. Traitormod.ClientLogName(reviveClient) .. " not found.", nil, ChatMessageType.Error, client)
    end

    return true
end)

Traitormod.AddCommand("!spawn", function (client, args)
    if not client.HasPermission(ClientPermissions.ConsoleCommands) then return end

    local spawnClient = client

    if #args > 0 then
        -- if client name is given, revive related character
        local name = table.remove(args, 1)
        -- find character by client name
        for player in Client.ClientList do
            if player.Name == name or player.SteamID == name then
                spawnClient = player
            end
        end
    end

    if spawnClient.Character == nil or spawnClient.Character.IsDead then
        MidRoundSpawn.TryCreateClientCharacter(spawnClient)
        Game.SendDirectChatMessage("", "Character of ".. Traitormod.ClientLogName(spawnClient) .. " successfully spawned.", nil, ChatMessageType.Server, client)
    else
        Game.SendDirectChatMessage("", "Character of " .. Traitormod.ClientLogName(spawnClient) .. " is alive.", nil, ChatMessageType.Error, client)
    end

    return true
end)

Traitormod.AddCommand("!ongoingevents", function (client, args)
    if not client.HasPermission(ClientPermissions.ConsoleCommands) then return end

    local text = "On Going Events: "
    for key, value in pairs(Traitormod.RoundEvents.OnGoingEvents) do
        text = text .. "\"" .. value.Name .. "\" "
    end

    Traitormod.SendMessage(client, text)

    return true
end)

Traitormod.AddCommand("!assignrole", function (client, args)
    if not client.HasPermission(ClientPermissions.ConsoleCommands) then return end
    
    if #args < 2 then
        Traitormod.SendMessage(client, "Usage: !assignrole <client> <role>")
        return true
    end

    local target = Traitormod.FindClient(args[1])

    if not target then
        Traitormod.SendMessage(client, "Couldn't find a client with specified name / steamID")
        return true
    end

    if target.Character == nil or target.Character.IsDead then
        Traitormod.SendMessage(client, "Client's character is dead or non-existent.")
        return true
    end

    local role = Traitormod.RoleManager.Roles[args[2]]

    if role == nil then
        Traitormod.SendMessage(client, "Couldn't find role to assign.")
        return true
    end

    local targetCharacter = target.Character

    if Traitormod.RoleManager.GetRole(targetCharacter) ~= nil then
        Traitormod.RoleManager.RemoveRole(targetCharacter)
    end
    Traitormod.RoleManager.AssignRole(targetCharacter, role:new())

    Traitormod.SendMessage(client, "Assign " .. target.Name .. " the role " .. role.Name .. ".")

    return true
end)

Traitormod.AddCommand("!triggerevent", function (client, args)
    if not client.HasPermission(ClientPermissions.ConsoleCommands) then return end

    if #args < 1 then
        Traitormod.SendMessage(client, "Usage: !triggerevent <event name>")
        return true
    end

    local event = nil
    for _, value in pairs(Traitormod.RoundEvents.EventConfigs.Events) do
        if value.Name == args[1] then
            event = value
        end
    end

    if event == nil then
        Traitormod.SendMessage(client, "Event " .. args[1] .. " doesnt exist.")
        return true
    end

    Traitormod.RoundEvents.TriggerEvent(event.Name)
    Traitormod.SendMessage(client, "Triggered event " .. event.Name)

    return true
end)

Traitormod.AddCommand({"!intercom"}, function (client, args)
    if not client.HasPermission(ClientPermissions.ConsoleCommands) then return end

    if #args < 1 then
        Traitormod.SendMessage(client, "Incorrect amount of arguments. usage: !announce [msg] - If you need to announce something with more than one word, surround it in quotations.")
    
        return true
    end

    local text = table.remove(args, 1)

    Traitormod.RoundEvents.SendEventMessage("Intercom: "..text, "GameModeIcon.sandbox", Color.LightGreen)

    return true
end)


Traitormod.AddCommand({"!funny"}, function (client, args)
    if not client.HasPermission(ClientPermissions.ConsoleCommands) then return end

    spawnPosition = Submarine.MainSub.WorldPosition

    local funnyClient = client

    if #args > 0 then
        -- if client name is given, revive related character
        local name = table.remove(args, 1)
        -- find character by client name
        for player in Client.ClientList do
            if player.Name == name or player.SteamID == name then
                funnyClient = player
            end
        end
    end

    Entity.Spawner.AddCharacterToSpawnQueue("mudraptor", spawnPosition, function (character)
        funnyClient.SetClientCharacter(character)
        character.TeamID = CharacterTeamType.FriendlyNPC
    end)

    return true
end)

Traitormod.AddCommand({"!locatesub", "!locatesubmarine"}, function (client, args)
    if client.Character == nil or not client.InGame then
        Traitormod.SendMessage(client, "You must be alive to use this command.")
        return true
    end

    if client.Character.IsHuman and client.Character.TeamID == CharacterTeamType.FriendlyNPC then
        Traitormod.SendMessage(client, "Only monsters are able to use this command.")
        return true
    end

    local center = client.Character.WorldPosition
    local target = Submarine.MainSub.WorldPosition

    local distance = Vector2.Distance(center, target) * Physics.DisplayToRealWorldRatio

    local diff = center - target

    local angle = math.deg(math.atan2(diff.X, diff.Y)) + 180

    local function degreeToOClock(v)
        local oClock = math.floor(v / 30)
        if oClock == 0 then oClock = 12 end
        return oClock .. " o'clock"
    end

    Game.SendDirectChatMessage("", "Submarine is " .. math.floor(distance) .. "m away from you, at " .. degreeToOClock(angle) .. ".", nil, ChatMessageType.Error, client)

    return true
end)


local preventSpam = {}
Traitormod.AddCommand({"!droppoints", "!droppoint", "!dropoint", "!dropoints"}, function (client, args)
    if preventSpam[client] ~= nil and Timer.GetTime() < preventSpam[client] then
        Traitormod.SendMessage(client, "Please wait a bit before using this command again.")
        return true
    end

    if client.Character == nil or client.Character.IsDead or client.Character.Inventory == nil then
        Traitormod.SendMessage(client, "You must be alive to use this command.")
        return true
    end

    if #args < 1 then
        Traitormod.SendMessage(client, "Usage: !droppoints amount")
        return true
    end

    local amount = tonumber(args[1])

    if amount == nil or amount ~= amount or amount < 100 or amount > 100000 then
        Traitormod.SendMessage(client, "Please specify a valid number between 100 and 100000.")
        return true
    end

    local availablePoints = Traitormod.GetData(client, "Points") or 0

    if amount > availablePoints then
        Traitormod.SendMessage(client, "You don't have enough points to drop.")
        return true
    end

    Traitormod.SpawnPointItem(client.Character.Inventory, tonumber(amount))
    Traitormod.SetData(client, "Points", availablePoints - amount)

    preventSpam[client] = Timer.GetTime() + 5

    return true
end)
local event = {}

-- Intense, can go from 0 to 1, defines how intense the round needs to be for the event to be triggered, 0 meaning the round is very chill and calm, 1 being that everything that could go wrong, has gone wrong.
-- MinRoundTime, the minimum amount of time that needs to be passed before the event can be triggered.
-- MaxRoundTime, same as above, but for max
-- ChancePerMinute, Every minute, this will roll a random to number to check if the event should be triggered.


event.Name = "CommunicationsOffline"
event.MinRoundTime = 10
event.MinIntensity = 0
event.MaxIntensity = 0.2
event.ChancePerMinute = 0.02
event.OnlyOncePerRound = true

event.AmountTime = 2 -- Communications are offline for 5 minutes


event.Start = function ()

    local text = "Something is interfering with all our communications systems. It's been estimated that communications will be offline for atleast " .. event.AmountTime .. " minutes."

    Traitormod.RoundEvents.SendEventMessage(text, "GameModeIcon.multiplayercampaign")

    for key, item in pairs(Item.ItemList) do
        if item ~= nil and item.Prefab.Identifier == "headset" then
            item.GetComponentString("WifiComponent").Range = 0;
        end
    end

    Hook.Add("item.created", "CommunicationsOffline.Item.Created", function (item)
        if item ~= nil and item.Prefab.Identifier == "headset" then
            item.GetComponentString("WifiComponent").Range = 10;
        end
    end)

    Timer.Wait(event.End, event.AmountTime * 57 * 1000)
end

event.End = function (isEndRound)
    Hook.Remove("item.created", "CommunicationsOffline.Item.Created")

    for key, item in pairs(Item.ItemList) do
        if item ~= nil and item.Prefab.Identifier == "headset" then
            item.GetComponentString("WifiComponent").Range = 35000;
        end
    end

    if not isEndRound then
        local text = "Communications are back online."

        Traitormod.RoundEvents.SendEventMessage(text, "GameModeIcon.multiplayercampaign")
    end
end

return eventlocal config = {}
config.DebugLogs = true

----- USER FEEDBACK -----
config.Language = "English"
config.SendWelcomeMessage = true
config.ChatMessageType = ChatMessageType.Private    -- Error = red | Private = green | Dead = blue | Radio = yellow

----- GAMEPLAY -----
config.Codewords = {
    "hull", "tabacco", "separatist", "fish", "clown", "quartermaster", "fast", "possibility",
	"thalamus", "hungry", "water", "looks", "renegade", "angry", "green", "sink", "rubber",
	"mask", "sweet", "ice", "charybdis", "cult", "secret", "frequency",
	"husk", "rust", "ruins", "red", "boat", "cats", "rats", "blast",
	"tire", "trunk", "weapons", "threshers", "convict", "method", "monkey"
}

config.AmountCodeWords = 2

config.OptionalTraitors = true        -- players can use !toggletraitor
config.RagdollOnDisconnect = false
config.EnableControlHusk = false     -- EXPERIMENTAL: enable to control husked character after death
config.DeathLogBook = true

-- This overrides the game's respawn shuttle, and uses it as a submarine injector, to spawn submarines in game easily. Respawn should still work as expected, but the shuttle submarine file needs to be manually added here.
-- Note: If this is disabled, traitormod will disable all functions related to submarine spawning.
-- Warning: Only respawn shuttles will be used, the option to spawn people directly into the submarine doesnt work.
config.OverrideRespawnSubmarine = true
config.RespawnSubmarineFile = "Content/Submarines/Selkie.sub"
config.RespawnText = "Respawn in %s seconds."
config.RespawnTeam = CharacterTeamType.Team1
config.RespawnOnKillPoints = 0

----- POINTS + LIVES -----
config.PermanentPoints = true      -- sets if points and lives will be stored in and loaded from a file
config.RemotePoints = nil
config.RemoteServerAuth = {}
config.PermanentStatistics = true  -- sets if statistics be stored in and loaded from a file
config.MaxLives = 5
config.MinRoundTimeToLooseLives = 210
config.RespawnedPlayersDontLooseLives = true
config.MaxExperienceFromPoints = 100000     -- if not nil, this amount is the maximum experience players gain from stored points (30k = lvl 10 | 38400 = lvl 12)
config.RemoveSkillBooks = true
config.NerfSwords = false

config.FreeExperience = 910         -- temporary experience given every ExperienceTimer seconds
config.ExperienceTimer = 120

config.PointsGainedFromSkill = {
    medical = 30,
    weapons = 20,
    mechanical = 19,
    electrical = 19,
    helm = 9,
}

config.PointsLostAfterNoLives = function (x)
    return x * 0.75
end

config.AmountExperienceWithPoints = function (x)
    return x
end

-- Give weight based on the logarithm of experience
-- 100 experience = 4 chance
-- 1000 experience = 6 chance
config.AmountWeightWithPoints = function (x)
    return math.log(x + 10) -- add 1 because log of 0 is -infinity
end

----- GAMEMODE -----
config.GamemodeConfig = {
    Secret = {
        EndOnComplete = true,           -- end round everyone but traitors are dead
        EnableRandomEvents = true,
        EndGameDelaySeconds = 15,

        TraitorSelectDelayMin = 120,
        TraitorSelectDelayMax = 150,

        PointsGainedFromHandcuffedTraitors = 1000,
        DistanceToEndOutpostRequired = 8000,

        MissionPoints = {
            Salvage = 1100,
            Monster = 1050,
            Cargo = 1000,
            Beacon = 1200,
            Nest = 1700,
            Mineral = 1000,
            Combat = 1400,
            AbandonedOutpost = 500,
            Escort = 1200,
            Pirate = 1300,
            GoTo = 1000,
            ScanAlienRuins = 1600,
            ClearAlienRuins = 2000,
            Default = 1000,
        },
        PointsGainedFromCrewMissionsCompleted = 1000,
        LivesGainedFromCrewMissionsCompleted = 1,

        TraitorTypeChance = {
            Traitor = 90, -- Traitors have 50% chance of being a normal traitor
            Cultist = 10,
        },

        AmountTraitors = function (amountPlayers)
            config.TestMode = false
            if amountPlayers > 12 then return 3 end
            if amountPlayers > 7 then return 2 end            
            if amountPlayers > 3 then return 1 end
            if amountPlayers == 1 then 
                Traitormod.SendMessageEveryone("1P testing mode - no points can be gained or lost") 
                config.TestMode = true
                return 1
            end
            print("Not enough players to start traitor mode.")
            return 0
        end,

        -- 0 = 0% chance
        -- 1 = 100% chance
        TraitorFilter = function (client)
            if client.Character.TeamID ~= CharacterTeamType.FriendlyNPC then return 0 end
            if not client.Character.IsHuman then return 0 end
            if client.Character.HasJob("warden") then return 0 end
            if client.Character.HasJob("headguard") then return 0 end
            if client.Character.HasJob("convict") then return 0 end
            if client.Character.HasJob("guard") then return 0.005 end
            if client.Character.HasJob("prisondoctor") then return 0.5 end

            return 1
        end
    },

    PvP = {
        EnableRandomEvents = false, -- most events are coded to only affect the main submarine
        WinningPoints = 1000,
        WinningDeadPoints = 500,
        MinimumPlayersForPoints = 4,
        ShowSonar = true,
        IdCardAllAccess = true,
        CrossTeamCommunication = true,
    },
}

config.RoleConfig = {
    Crew = {
        AvailableObjectives = {
            ["captain"] = {},
            ["engineer"] = {},
            ["mechanic"] = {"Repair"},
            ["janitor"] = {"Repair"},
            ["staff"] = {"Repair"},
            ["securityofficer"] = {"KillMonsters"},
            ["warden"] = {"KillMonsters"},
            ["guard"] = {"KillMonsters"},
            ["headguard"] = {"KillMonsters"},
            ["medic"] = {},
            ["prisondoctor"] = {},
            ["convict"] = {"Escape"},
        }
    },

    Cultist = {
        SubObjectives = {"Assassinate", "Kidnap", "TurnHusk", "DestroyCaly"},
        MinSubObjectives = 2,
        MaxSubObjectives = 3,

        NextObjectiveDelayMin = 30,
        NextObjectiveDelayMax = 60,

        TraitorBroadcast = true,           -- traitors can broadcast to other traitors using !tc
        TraitorBroadcastHearable = false,  -- if true, !tc will be hearable in the vicinity via local chat
        TraitorDm = true,                  -- traitors can send direct messages to other players using !tdm

        -- Names, None
        TraitorMethodCommunication = "Names",

        SelectBotsAsTargets = true,
        SelectPiratesAsTargets = false,
    },

    HuskServant = {
        TraitorBroadcast = true,
    },

    Traitor = {
        SubObjectives = {"StealCaptainID", "Survive", "Kidnap", "PoisonCaptain", "SavePrisoner"},
        MinSubObjectives = 2,
        MaxSubObjectives = 3,

        NextObjectiveDelayMin = 30,
        NextObjectiveDelayMax = 60,

        TraitorBroadcast = true,           -- traitors can broadcast to other traitors using !tc
        TraitorBroadcastHearable = false,  -- if true, !tc will be hearable in the vicinity via local chat
        TraitorDm = true,                  -- traitors can send direct messages to other players using !tdm

        -- Names, Codewords, None
        TraitorMethodCommunication = "Names",

        SelectBotsAsTargets = true,
        SelectPiratesAsTargets = false,
        SelectUniqueTargets = true,     -- every traitor target can only be chosen once per traitor (respawn+false -> no end)
        PointsPerAssassination = 100,
    },
}

config.ObjectiveConfig = {
    Assassinate = {
        AmountPoints = 600,
    },

    SavePrisoner = {
        AmountPoints = 2100,
    },

    OnAcid = {
        AmountPoints = 500,
    },

    Survive = {
        AlwaysActive = true,
        AmountPoints = 500,
        AmountLives = 1,
    },

    StealCaptainID = {
        AmountPoints = 1300,
    },

    Kidnap = {
        AmountPoints = 2500,
        Seconds = 100,
    },

    PoisonCaptain = {
        AmountPoints = 1600,
    },

    Husk = {
        AmountPoints = 750,
    },

    TurnHusk = {
        AmountPoints = 500,
        AmountLives = 1,
    },

    DestroyCaly = {
        AmountPoints = 500,
    },
}

----- EVENTS -----
config.RandomEventConfig = {
    Events = {
        dofile(Traitormod.Path .. "/Lua/config/randomevents/communicationsoffline.lua"),
        dofile(Traitormod.Path .. "/Lua/config/randomevents/superballastflora.lua"),
        dofile(Traitormod.Path .. "/Lua/config/randomevents/maintenancetoolsdelivery.lua"),
        dofile(Traitormod.Path .. "/Lua/config/randomevents/medicaldelivery.lua"),
        dofile(Traitormod.Path .. "/Lua/config/randomevents/ammodelivery.lua"),
        dofile(Traitormod.Path .. "/Lua/config/randomevents/electricalfixdischarge.lua"),
        dofile(Traitormod.Path .. "/Lua/config/randomevents/wreckpirate.lua"),
        dofile(Traitormod.Path .. "/Lua/config/randomevents/beaconpirate.lua"),
        dofile(Traitormod.Path .. "/Lua/config/randomevents/lightsoff.lua"),
        dofile(Traitormod.Path .. "/Lua/config/randomevents/emergencyteam.lua"),
        dofile(Traitormod.Path .. "/Lua/config/randomevents/shadymission.lua"),
        dofile(Traitormod.Path .. "/Lua/config/randomevents/oxygengenpoison.lua"),
    }
}

config.PointShopConfig = {
    Enabled = true,
    DeathTimeoutTime = 120,
    ItemCategories = {
        dofile(Traitormod.Path .. "/Lua/config/pointshop/cultist.lua"),
        dofile(Traitormod.Path .. "/Lua/config/pointshop/traitor.lua"),
        dofile(Traitormod.Path .. "/Lua/config/pointshop/security.lua"),
        dofile(Traitormod.Path .. "/Lua/config/pointshop/maintenance.lua"),
        dofile(Traitormod.Path .. "/Lua/config/pointshop/experimental.lua"),
        dofile(Traitormod.Path .. "/Lua/config/pointshop/deathspawn.lua"),
        dofile(Traitormod.Path .. "/Lua/config/pointshop/ships.lua"),
        dofile(Traitormod.Path .. "/Lua/config/pointshop/prisoner.lua"),
    }
}

config.GhostRoleConfig = {
    Enabled = true,
    MiscGhostRoles = {
        ["Watcher"] = true,
        ["Mudraptor_pet"] = true,
        ["Orangeboy"] = true,
        ["Peanut"] = true,
        ["Huskmutantarmored"] = true,
        ["Huskmutantarmoredpucs"] = true,
        ["Huskmutanthunter"] = true,
        ["Huskmutanthumanhead"] = true,
        ["Huskmutanthumantorso"] = true,
        ["humanhuskold"] = true,
        ["Humanshambler"] = true,
        ["Huskmutantcocoonhuman"] = true,
        ["Huskpucsold"] = true,
        ["Huskabyssold"] = true,
        ["Huskslipold"] = true,
        ["Huskcontainer"] = true,
        ["Psilotoad"] = true,
        ["Humanzombiestaggerer"] = true,
        ["Huskmutanthuman"] = true,
        ["Mantishusk"] = true,
        ["Crawlerhusk"] = true,
        ["Hammerheadspawn"] = true,
        ["Hammerheadmatriarch"] = true,
        ["Mudraptorhusk"] = true,
    }
}

return configlocal role = Traitormod.RoleManager.Roles.Role:new()
role.Name = "Crew"
role.Antagonist = false

function role:Start()
    local job = self.Character.Info.Job.Prefab.Identifier.Value
    
    local availableObjectives = self.AvailableObjectives[job]

    if not availableObjectives or #availableObjectives == 0 then
        return
    end

    local pool = {}
    for key, value in pairs(availableObjectives) do pool[key] = value end

    for i = 1, 3, 1 do
        local objective = Traitormod.RoleManager.RandomObjective(pool)
        if objective == nil then break end

        objective = objective:new()

        local character = self.Character
        objective:Init(character)
        local target = self:FindValidTarget(objective)

        if objective:Start(target) then
            self:AssignObjective(objective)
            for key, value in pairs(pool) do
                if value == objective.Name then
                    table.remove(pool, key)
                end
            end
        end
    end

    local text = self:Greet()
    local client = Traitormod.FindClientCharacter(self.Character)
    if client then
        Traitormod.SendChatMessage(client, text, Color.Green)
    end
end


function role:End(roundEnd)

end

---@return string objectives
function role:ObjectivesToString()
    local objs = Traitormod.StringBuilder:new()

    for _, objective in pairs(self.Objectives) do
        if objective:IsCompleted() then
            objs:append(" > ", objective.Text, Traitormod.Language.Completed)
        else
            objs:append(" > ", objective.Text, string.format(Traitormod.Language.Points, objective.AmountPoints))
        end
    end

    return objs:concat("\n")
end

function role:Greet()
    local objectives = self:ObjectivesToString()

    local sb = Traitormod.StringBuilder:new()
    sb("You are crew member of the submarine.\n\n")
    sb("You have been assigned the following objectives which when completing all will grant you one live.\n\n")
    sb(objectives)

    return sb:concat()
end

function role:OtherGreet()
    return ""
end


return role
local category = {}

category.Name = "Cultist"
category.Decoration = "cultist"
category.FadeToBlack = true

category.CanAccess = function(client)
    return client.Character and not client.Character.IsDead and Traitormod.RoleManager.HasRole(client.Character, "Cultist")
end

LuaUserData.MakeMethodAccessible(Descriptors["Barotrauma.StatusEffect"], "set_Afflictions")
LuaUserData.MakeFieldAccessible(Descriptors["Barotrauma.Affliction"], "_strength")

category.Init = function ()
    local replacement = [[
        <overwrite>
        <!--Can't fail, but can't use OnUse for projectiles-->
        <StatusEffect type="OnUse" target="This">
            <LuaHook name="Cultist.Injected" />
        </StatusEffect>
        <StatusEffect type="OnSuccess" target="This" Condition="-100.0" setvalue="true"/>
        <StatusEffect type="OnSuccess" target="UseTarget" duration="60.0">
          <!-- HuskInfectionState must be less than 0.01 so you can't speed up the infection -->
          <Affliction identifier="huskinfection" amount="1" />
        </StatusEffect>
        <StatusEffect type="OnSuccess" target="UseTarget">
          <Conditional entitytype="eq Character"/>
          <Sound file="Content/Items/Medical/Syringe.ogg" range="500" />
        </StatusEffect>
        <StatusEffect type="OnImpact" target="UseTarget" multiplyafflictionsbymaxvitality="true" AllowWhenBroken="true">
          <Affliction identifier="stun" amount="0.1" />
        </StatusEffect>
        <!-- Remove the item when fully used -->
        <StatusEffect type="OnBroken" target="This">
          <Remove />
        </StatusEffect>
        </overwrite>
    ]]

    local husk = ItemPrefab.GetItemPrefab("huskeggs")
    local element = husk.ConfigElement.Element.Element("MeleeWeapon")
    Traitormod.Patching.RemoveAll(element, "StatusEffect")
    Traitormod.Patching.Add(element, replacement)

    Hook.Add("Cultist.Injected", "Cultist.Injected", function (effect, deltaTime, item, targets, worldPosition)
        if item.HasTag("active") then
            if item.ParentInventory ~= nil and LuaUserData.IsTargetType(item.ParentInventory.Owner, "Barotrauma.Item") then
                local injector = item.ParentInventory.Owner
                if injector.ParentInventory ~= nil and LuaUserData.IsTargetType(injector.ParentInventory.Owner, "Barotrauma.Character") then
                    local character = injector.ParentInventory.Owner
                    if character.Inventory.GetItemInLimbSlot(InvSlotType.Headset) == injector then
                        local affliction = AfflictionPrefab.Prefabs["huskinfection"].Instantiate(95)
                        character.CharacterHealth.ApplyAffliction(character.AnimController.MainLimb, affliction)    
                    end
                end
            end
        end
    end)

end

category.Products = {
    {
        Name = "Calyx Extract",
        Price = 100,
        Limit = 8,
        IsLimitGlobal = false,
        Items = {"huskeggs"},
    },

    {
        Name = "Husk Stinger",
        Price = 150,
        Limit = 4,
        IsLimitGlobal = false,
        Items = {"huskstinger"},
    },

    {
        Name = "Husk Auto-Injector",
        Price = 800,
        Limit = 1,
        IsLimitGlobal = false,
        Action = function (client)
            local prefabInjector = ItemPrefab.GetItemPrefab("autoinjectorheadset")
            local prefabUEX = ItemPrefab.GetItemPrefab("huskeggs")
            Entity.Spawner.AddItemToSpawnQueue(prefabInjector, client.Character.Inventory, nil, nil, function (item)
                Entity.Spawner.AddItemToSpawnQueue(prefabUEX, item.OwnInventory, nil, nil, function (item2)
                    item2.Description = "Highly active husk eggs."
                    item2.set_InventoryIconColor(Color(0, 0, 255))
                    item2.SpriteColor = Color(0, 0, 255, 255)
                    item2.AddTag("active")

                    local color = item2.SerializableProperties[Identifier("SpriteColor")]
                    Networking.CreateEntityEvent(item2, Item.ChangePropertyEventData(color, item2))
                    local invColor = item2.SerializableProperties[Identifier("InventoryIconColor")]
                    Networking.CreateEntityEvent(item2, Item.ChangePropertyEventData(invColor, item2))

                    item2.NonPlayerTeamInteractable = true
                    local prop = item2.SerializableProperties[Identifier("NonPlayerTeamInteractable")]
                    Networking.CreateEntityEvent(item2, Item.ChangePropertyEventData(prop, item2))
                end)
            end)
        end
    },

    {
        Name = "Husked Blood Pack",
        Price = 350,
        Limit = 4,
        IsLimitGlobal = false,
        Action = function (client)
            local prefabInjector = ItemPrefab.GetItemPrefab("antibloodloss2")
            Entity.Spawner.AddItemToSpawnQueue(prefabInjector, client.Character.Inventory, nil, nil, function (item)
                local holdable = item.GetComponentString("Holdable")

                local husk = AfflictionPrefab.Prefabs["huskinfection"]

                local effect = holdable.statusEffectLists[22][1]
                effect.set_Afflictions({husk.Instantiate(0.5)})

                effect = holdable.statusEffectLists[9][1]
                effect.set_Afflictions({husk.Instantiate(0.5)})

            end)
        end
    },

    {
        Name = "Firemans Carry Talent",
        Price = 350,
        Limit = 1,
        IsLimitGlobal = false,
        Action = function (client, product, items)
            client.Character.GiveTalent("firemanscarry")
        end
    },

    {
        Name = "Spawn Husk",
        Price = 400,
        Limit = 5,
        Action = function (client, product, items)
            Entity.Spawner.AddCharacterToSpawnQueue("husk", client.Character.WorldPosition, function (character)
            end)
        end
    },

    {
        Name = "Invisibility Gear",
        Price = 800,
        Limit = 1,
        IsLimitGlobal = false,
        Action = function (client)
            local suit = ItemPrefab.GetItemPrefab("divingsuit")
            Entity.Spawner.AddItemToSpawnQueue(suit, client.Character.Inventory, nil, nil, function (item)
                local light = item.GetComponentString("LightComponent")

                item.set_InventoryIconColor(Color(100, 100, 100, 50))
                item.SpriteColor = Color(0, 0, 0, 0)
                item.Tags = "smallitem"
                light.LightColor = Color(0, 0, 0, 0)

                local color = item.SerializableProperties[Identifier("SpriteColor")]
                Networking.CreateEntityEvent(item, Item.ChangePropertyEventData(color, item))            
                local invColor = item.SerializableProperties[Identifier("InventoryIconColor")]
                Networking.CreateEntityEvent(item, Item.ChangePropertyEventData(invColor, item))
                local lightColor = light.SerializableProperties[Identifier("LightColor")]
                Networking.CreateEntityEvent(item, Item.ChangePropertyEventData(lightColor, light))

                Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("oxygentank"), item.OwnInventory)
            end)

            local robes = ItemPrefab.GetItemPrefab("zealotrobes")
            Entity.Spawner.AddItemToSpawnQueue(robes, client.Character.Inventory, nil, nil, function (item)

                item.set_InventoryIconColor(Color(100, 100, 100, 50))
                item.SpriteColor = Color(0, 0, 0, 0)
                item.Tags = "smallitem"

                local color = item.SerializableProperties[Identifier("SpriteColor")]
                Networking.CreateEntityEvent(item, Item.ChangePropertyEventData(color, item))            
                local invColor = item.SerializableProperties[Identifier("InventoryIconColor")]
                Networking.CreateEntityEvent(item, Item.ChangePropertyEventData(invColor, item))
            end)

            local cap = ItemPrefab.GetItemPrefab("ironhelmet")
            Entity.Spawner.AddItemToSpawnQueue(cap, client.Character.Inventory, nil, nil, function (item)

                item.set_InventoryIconColor(Color(100, 100, 100, 50))
                item.SpriteColor = Color(0, 0, 0, 0)
                item.Tags = "smallitem"

                local color = item.SerializableProperties[Identifier("SpriteColor")]
                Networking.CreateEntityEvent(item, Item.ChangePropertyEventData(color, item))            
                local invColor = item.SerializableProperties[Identifier("InventoryIconColor")]
                Networking.CreateEntityEvent(item, Item.ChangePropertyEventData(invColor, item))
            end)
        end
    },

    {
        Name = "Advanced Syringe Gun",
        Price = 500,
        Limit = 1,
        IsLimitGlobal = false,
        Items = {"advancedsyringegun"},
    },

    {
        Name = "Europan Medicine",
        Price = 400,
        Limit = 1,
        IsLimitGlobal = false,
        Items = {"skillbookeuropanmedicine"},
    },

    {
        Name = "Acid Grenade (4x)",
        Price = 370,
        Limit = 3,
        IsLimitGlobal = false,
        Items = {"chemgrenade", "chemgrenade", "chemgrenade", "chemgrenade"},
    },

    {
        Name = "Europabrew (4x)",
        Price = 120,
        Limit = 3,
        IsLimitGlobal = false,
        Items = {"europabrew", "europabrew", "europabrew", "europabrew"},
    },

    {
        Name = "Chloral Hydrate (4x)",
        Price = 250,
        Limit = 4,
        IsLimitGlobal = false,
        Items = {"chloralhydrate", "chloralhydrate", "chloralhydrate", "chloralhydrate"},
    },

    {
        Name = "Detonator",
        Price = 950,
        Limit = 3,
        IsLimitGlobal = false,
        Items = {"detonator"},
    },
}

return categorylocal category = {}

category.Name = "Death Spawn"
category.Decoration = "huskinvite"

category.CanAccess = function(client)
    return client.Character == nil or client.Character.IsDead or not client.Character.IsHuman
end

local function SpawnCreature(species, client, insideHuman)
    local waypoints = Submarine.MainSub.GetWaypoints(true)

    if LuaUserData.IsTargetType(Game.GameSession.GameMode, "Barotrauma.PvPMode") then
        waypoints = Submarine.MainSubs[math.random(2)].GetWaypoints(true)
    end

    local spawnPositions = {}

    if insideHuman then
        for key, value in pairs(Character.CharacterList) do
            if value.IsHuman and not value.IsDead and value.TeamID == CharacterTeamType.Team1 then
                table.insert(spawnPositions, value.WorldPosition)
            end
        end
    else
        for key, value in pairs(waypoints) do
            if value.CurrentHull == nil then
                local walls = Level.Loaded.GetTooCloseCells(value.WorldPosition, 250)
                if #walls == 0 then
                    table.insert(spawnPositions, value.WorldPosition)
                end
            end
        end
    end

    local spawnPosition

    if #spawnPositions == 0 then
        -- no waypoints? https://c.tenor.com/RgExaLgYIScAAAAC/megamind-megamind-meme.gif
        spawnPosition = Submarine.MainSub.WorldPosition -- spawn it in the middle of the sub

        Traitormod.Log("Couldnt find any good waypoints, spawning in the middle of the sub.")
    else
        spawnPosition = spawnPositions[math.random(#spawnPositions)]
    end

    Entity.Spawner.AddCharacterToSpawnQueue(species, spawnPosition, function (character)
        client.SetClientCharacter(character)
    end)
end

category.Products = {
    {
        Name = "Spawn as Crawler",
        Price = 400,
        Limit = 4,
        IsLimitGlobal = true,
        PricePerLimit = 100,
        Timeout = 60,

        Action = function (client, product, items)
            SpawnCreature("crawler", client)
        end
    },

    {
        Name = "Spawn as Zombie Sprinter",
        Price = 1100,
        Limit = 2,
        IsLimitGlobal = true,
        PricePerLimit = 750,
        Timeout = 60,

        Action = function (client, product, items)
            SpawnCreature("Humanzombiesprinter", client)
        end
    },

    {
        Name = "Spawn as Zombie Staggerer",
        Price = 900,
        Limit = 2,
        IsLimitGlobal = true,
        PricePerLimit = 350,
        Timeout = 60,

        Action = function (client, product, items)
            SpawnCreature("Humanzombiestaggerernatural", client)
        end
    },

    {
        Name = "Spawn as Legacy Husk",
        Price = 450,
        Limit = 5,
        IsLimitGlobal = true,
        PricePerLimit = 0,
        Timeout = 60,

        Action = function (client, product, items)
            SpawnCreature("legacyhusk", client)
        end
    },

    {
        Name = "Spawn as Crawler Baby",
        Price = 250,
        Limit = 4,
        IsLimitGlobal = true,
        PricePerLimit = 10,
        Timeout = 60,

        Action = function (client, product, items)
            SpawnCreature("crawler_hatchling", client)
        end
    },

    {
        Name = "Spawn as Mudraptor Baby",
        Price = 400,
        Limit = 5,
        IsLimitGlobal = true,
        PricePerLimit = 150,
        Timeout = 60,

        Action = function (client, product, items)
            SpawnCreature("mudraptor_hatchling", client)
        end
    },

    {
        Name = "Spawn as Thresher Baby",
        Price = 700,
        Limit = 5,
        IsLimitGlobal = true,
        PricePerLimit = 250,
        Timeout = 60,

        Action = function (client, product, items)
            SpawnCreature("tigerthresher_hatchling", client)
        end
    },

    {
        Name = "Spawn as Spineling",
        Price = 1000,
        Limit = 1,
        IsLimitGlobal = true,
        PricePerLimit = 250,
        Timeout = 60,

        Action = function (client, product, items)
            SpawnCreature("spineling", client)
        end
    },

    {
        Name = "Spawn as Mudraptor",
        Price = 1000,
        Limit = 3,
        IsLimitGlobal = true,
        PricePerLimit = 100,
        Timeout = 60,

        Action = function (client, product, items)
            SpawnCreature("mudraptor", client)
        end
    },

    {
        Name = "Spawn as Mantis",
        Price = 1100,
        Limit = 2,
        IsLimitGlobal = true,
        PricePerLimit = 200,
        Timeout = 60,

        Action = function (client, product, items)
            SpawnCreature("mantis", client)
        end
    },

    {
        Name = "Spawn as Husk",
        Price = 1800,
        Limit = 2,
        IsLimitGlobal = true,
        PricePerLimit = 400,
        Timeout = 60,

        Action = function (client, product, items)
            SpawnCreature("huskold", client)
        end
    },

    {
        Name = "Spawn as Bone Thresher",
        Price = 1800,
        Limit = 2,
        IsLimitGlobal = true,
        PricePerLimit = 500,
        Enabled = true,
        Timeout = 60,

        Action = function (client, product, items)
            SpawnCreature("Bonethresher", client)
        end
    },

    {
        Name = "Spawn as Tiger Thresher",
        Price = 2500,
        Limit = 2,
        IsLimitGlobal = true,
        PricePerLimit = 500,
        Enabled = true,
        Timeout = 60,

        Action = function (client, product, items)
            SpawnCreature("Tigerthresher", client)
        end
    },

    {
        Name = "Spawn as Legacy Moloch (Horrible)",
        Price = 2500,
        Limit = 1,
        IsLimitGlobal = true,
        PricePerLimit = 500,
        Enabled = true,
        Timeout = 60,

        Action = function (client, product, items)
            SpawnCreature("legacymoloch", client)
        end
    },

    {
        Name = "Spawn as Hammerhead",
        Price = 2500,
        Limit = 2,
        IsLimitGlobal = true,
        PricePerLimit = 1000,
        Enabled = true,
        Timeout = 60,

        Action = function (client, product, items)
            SpawnCreature("hammerhead", client)
        end
    },

    {
        Name = "Spawn as Fractal Guardian",
        Price = 4900,
        Limit = 1,
        IsLimitGlobal = true,
        PricePerLimit = 3000,
        Timeout = 60,

        Action = function (client, product, items)
            SpawnCreature("fractalguardian", client)
        end
    },

    {
        Name = "Spawn as Giant Spineling",
        Price = 20000,
        Limit = 1,
        IsLimitGlobal = true,
        PricePerLimit = 1000,
        Enabled = true,
        Timeout = 60,

        Action = function (client, product, items)
            SpawnCreature("Spineling_giant", client)
        end
    },

    {
        Name = "Spawn as Veteran Mudraptor",
        Price = 8000,
        Limit = 2,
        IsLimitGlobal = true,
        PricePerLimit = 1000,
        Enabled = true,
        Timeout = 60,

        Action = function (client, product, items)
            SpawnCreature("Mudraptor_veteran", client)
        end
    },

    {
        Name = "Spawn as Latcher",
        Price = 50000,
        Limit = 1,
        IsLimitGlobal = true,
        PricePerLimit = 50000,
        Timeout = 60,

        Action = function (client, product, items)
            SpawnCreature("latcher", client)
        end
    },

    {
        Name = "Spawn as Charybdis",
        Price = 80000,
        Limit = 1,
        IsLimitGlobal = true,
        PricePerLimit = 50000,
        Timeout = 60,

        Action = function (client, product, items)
            SpawnCreature("charybdis", client)
        end
    },
}

return categorylocal objective = Traitormod.RoleManager.Objectives.Objective:new()

objective.Name = "DestroyCaly"
objective.AmountPoints = 500

function objective:Start(target)
    self.Items = {}
    for key, value in pairs(Submarine.MainSub.GetItems(false)) do
        if value.Prefab.Identifier == "calyxanide" then
            table.insert(self.Items, value)
            cool = value
        end
    end

    self.Amount = math.min(2, #self.Items)

    if self.Amount == 0 then return false end

    self.Text = string.format("Deconstruct " .. self.Amount .. " Calyxanide(s).", self.TargetName)

    return true
end

function objective:IsCompleted()
    local destroyed = 0
    for key, value in pairs(self.Items) do
        if value.Removed and value.Condition > 50 then
            destroyed = destroyed + 1
        end
    end

    if destroyed >= self.Amount then
        return true
    end

    return false
end

return objective
local objective = Traitormod.RoleManager.Objectives.Objective:new()

objective.Name = "DrunkSailor"
objective.AmountPoints = 500

function objective:Start(target)
    self.Target = target

    if self.Target == nil then
        return false
    end

    self.TargetName = Traitormod.GetJobString(self.Target)

    self.Text = string.format("Give %s more than 80% drunkness.", self.TargetName)

    return true
end

function objective:IsCompleted()
    if self.Target == nil then
        return
    end

    local aff = self.Target.CharacterHealth.GetAffliction("drunk", true)

    if aff ~= nil and aff.Strength > 80 then
        return true
    end

    return false
end

return objective
local event = {}

event.Name = "ElectricalFixDischarge"
event.MinRoundTime = 0
event.MinIntensity = 0.8
event.MaxIntensity = 1
event.ChancePerMinute = 0.05
event.OnlyOncePerRound = false

local allowedItems = {"junctionbox", "supercapacitor", "battery"}

event.Start = function ()
    for key, item in pairs(Submarine.MainSub.GetItems(true)) do
        for _, allowed in pairs(allowedItems) do
            if item.Prefab.Identifier.Value == allowed then
                item.Condition = item.Condition + 10
            end
        end
    end

    event.End()
end


event.End = function ()

end

return eventlocal event = {}

event.Enabled = true
event.Name = "EmergencyTeam"
event.MinRoundTime = 5
event.MinIntensity = 0.8
event.MaxIntensity = 1
event.ChancePerMinute = 0.05
event.OnlyOncePerRound = true

event.Start = function()
    local areas = {}

    for key, value in pairs(Submarine.MainSub.GetHulls(true)) do
        if value.IsTaggedAirlock() then
            table.insert(areas, value)
        end
    end

    if #areas == 0 then
        table.insert(areas, Submarine.MainSub)
    end

    local area = areas[math.random(#areas)]

    local jobs = {"mechanic", "engineer"}

    for i = 1, 4, 1 do
        local info = CharacterInfo(Identifier("human"))
        info.Job = Job(JobPrefab.Get(jobs[math.random(#jobs)]))

        local character = Character.Create(info, area.WorldPosition, info.Name, 0, false, true)

        character.TeamID = CharacterTeamType.Team1
        character.GiveJobItems(nil)
        character.CanSpeak = false

        Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("divingsuit"), character.Inventory, nil, nil, function (item)
            Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("oxygenitetank"), item.OwnInventory)
        end)

        Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("weldingtool"), character.Inventory, nil, nil, function (item)
            Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("weldingfueltank"), item.OwnInventory)
        end)

        if info.Job.Prefab.Identifier == "mechanic" then
            local repairOrderPrefab = OrderPrefab.Prefabs["repairsystems"]
            local repairOrder = Order(repairOrderPrefab, nil, nil).WithManualPriority(CharacterInfo.HighestManualOrderPriority)
            character.SetOrder(repairOrder, true, false, true)
        elseif info.Job.Prefab.Identifier == "engineer" then
            local repairOrderPrefab = OrderPrefab.Prefabs["repairelectrical"]
            local repairOrder = Order(repairOrderPrefab, nil, nil).WithManualPriority(CharacterInfo.HighestManualOrderPriority)
            character.SetOrder(repairOrder, true, false, true)
        end

        local leakOrderPrefab = OrderPrefab.Prefabs["fixleaks"]
        local leakOrder = Order(leakOrderPrefab, nil, nil).WithManualPriority(CharacterInfo.HighestManualOrderPriority)
        character.SetOrder(leakOrder, true, false, true)
    end

    local text = "A group of engineers and mechanics have entered the submarine to assist with repairs."
    Traitormod.RoundEvents.SendEventMessage(text, "GameModeIcon.sandbox")

    event.End()
end



event.End = function()

end

return event
local language = {}
language.Name = "English"

language.TipText = "Pro Tip: "
language.Tips = {
    "You can use !shop to spawn as creatures when you are dead.",
    "Traitors have access to a special traitor shop. Use !shop to open it.",
    "You can use !traitor to get information about your traitor status.",
    "You can use !help to get a list of all available commands.",
    "You can use !write to write text to a logbook that spawns when you die.",
    "The warden and head guard can never be traitors.",
    "Ghost roles might become available when you are dead, you can use !ghostrole to claim them.",
    "Typing !kill in chat as a ghost role simply returns it to the list of available ghost roles, rather than killing it.",
    "Fabricating, fixing hulls, healing and killing monsters grant you points.",
    "Doctors and normal guards can be traitors, but at a lower chance.",
    "If you have the Warden's ID, you can send a global announcement via !announce. Use this to communicate with the crew that do not have radios, or issue announcements for the prisoners and such. Make sure the ID doesn't get in the wrong hands though..",
}

language.Help = "\n!help - shows this help message\n!helptraitor - shows all traitor commands\n!helpadmin - lists all admin commands\n!traitor - show traitor information\n!pointshop - opens the point shop\n!points - show your points and lives\n!alive - list alive players (only while dead)\n!locatesub - shows you the distance and direction of the submarine, only for monsters\n!suicide - kills your character\n!version - shows running version of the traitormod\n!write - writes to your death logbook\n!announce [msg] - if you have the warden's ID, sends an announcement"
language.HelpTraitor = "\n!toggletraitor - toggles if the player can be selected as traitor\n!tc [msg] - sends a message to all traitors\n!tdm [Name] [msg] - sends a anonymous msg to given player"
language.HelpAdmin = "\n!traitoralive - check if all traitors died\n!roundinfo - show round information (spoiler!)\n!allpoints - shows point amounts of all connected clients\n!addpoint [Client] [+/-Amount] - add points to a client\n!addlife [Client] [+/-Amount] - add life(s) to a client\n!revive [Client] - revives a given client character\n!void [Character Name] - sends a character to the void\n!unvoid [Character Name] - brings a character back from the void\n!vote [text] [option1] [option2] [...] - starts a vote on the server\n!intercom [msg] - sends a global announcement as 'intercom'"

language.NoTraitor = "You aren't a traitor."
language.TraitorOn = "You can be selected as traitor."
language.TraitorOff = "You can not be chosen traitor.\n\nUse !toggletraitor to change that."
language.RoundNotStarted = "Round not started."

language.AllTraitorsDead = "All traitors dead!"
language.TraitorsAlive = "There's still traitors alive."

language.Alive = "Alive"
language.Dead = "Dead"

language.KilledByTraitor = "Your death may be caused by a traitor on a secret mission."

language.TraitorWelcome = "You are a traitor!"
language.TraitorDeath = "You have failed in your mission. As a result, the mission has been canceled and you will come back as part of the crew.\n\nYou are no longer a traitor, so play nice!"
language.TraitorDirectMessage = "You received a secret message from a traitor:\n"
language.TraitorBroadcast = "[Traitor %s]: %s"

language.AgentNoticeCodewords = "There are other agents on this submarine. You dont know their names, but you do have a method of communication. Use the code words to greet the agent and code response to respond. Disguise such words in a normal-looking phrase so the crew doesn't suspect anything."

language.AgentNoticeNoCodewords = "There are other agents on this submarine. You know their names, cooperate with them so you have a higher chance of success."

language.AgentNoticeOnlyTraitor = "You are the only traitor on this ship, proceed with caution."

language.RoundSummary = "| Round Summary |"
language.Gamemode = "Gamemode: %s"
language.RandomEvents = "Random Events: %s"
language.ObjectiveCompleted = "Objective completed: %s"
language.ObjectiveFailed = "Objective failed: %s"

language.CrewWins = "The crew successfully completed their mission!"
language.TraitorHandcuffed = "The crew handcuffed the traitor %s."
language.TraitorsWin = "The traitors succeeded in completing their objectives!"

language.TraitorsRound = "Traitors of the round:"
language.NoTraitors = "No traitors."
language.TraitorAlive = "You survived as a traitor."

language.PointsInfo = "You have %s points and %s/%s lives."
language.TraitorInfo = "Your traitor chance is %s%%, compared to the rest of the crew."

language.Points = " (%s Points)"
language.Experience = " (%s XP)"

language.SkillsIncreased = "Good job on improving your skills."
language.PointsAwarded = "You have been awarded %s points."
language.PointsAwardedRound = "This round you gained:\n%s points"
language.ExperienceAwarded = "You gained %s XP."

language.LivesGained = "You gained %s. You now have %s/%s Lives."
language.ALife = "one life"
language.Lives = " lives"
language.Death = "You lost a life. You have %s left before you lose points."
language.NoLives = "You lost all your lives. As a result you lose some points."
language.MaxLives = "You have the maximum amount of lives."

language.Codewords = "Code Words: %s"
language.CodeResponses = "Code Responses: %s"

language.OtherTraitors = "All Traitors: %s"

language.CommandTip = "(Type !traitor in chat to show this message again.)"
language.CommandNotActive = "This command is deactivated."

language.Completed = " (Completed)"

language.Objective = "Main Objectives:"
language.SubObjective = "Sub Objectives (optional):"

language.NoObjectives = "No objectives."
language.NoObjectivesYet = "No targets yet..."

language.ObjectiveAssassinate = "Assassinate %s."

language.ObjectiveSurvive = "Complete at least one objective and survive the shift."
language.ObjectiveStealCaptainID = "Steal the captain's ID."
language.ObjectiveKidnap = "Handcuff %s for %s seconds."
language.ObjectivePoisonCaptain = "Poison %s with %s."
language.SavePrisoner = "Free %s from this filthy prison."
language.ObjectiveWreckGift = "Grab the gift"

language.ObjectiveText = "Assassinate the crew in order to complete your mission."

language.AssassinationNextTarget = "Stay low until further instructions."
language.AssassinationNewObjective = "Your next assassination target is %s."
language.HuskNewObjective = "Your next husk target is %s."
language.AssassinationEveryoneDead = "Good job agent, you did it!"

language.ItemsBought = "Items bought from point shop"
language.CrewBoughtItem = "Players bought items from point shop"
language.PointsGained = "Total points gained"
language.PointsLost = "Total points lost"
language.Spawns = "Spawned human characters"
language.Traitor = "Chosen as traitor"
language.TraitorDeaths = "Died as traitor"
language.TraitorMainObjectives ="Main Objectives successful"
language.TraitorSubObjectives = "Sub Objectives successful"
language.CrewDeaths = "Deaths"
language.Rounds = "General Round stats"

return languagelocal objective = Traitormod.RoleManager.Objectives.Objective:new()

objective.Name = "Escape"
objective.AmountPoints = 1500
objective.Amount = 5

function objective:Start(target)
    self.Text = "Escape."

    return true
end

function objective:IsCompleted()
    if self.Character.Submarine ~= Submarine.MainSub then
        return true
    end

    return false
end

return objective
local category = {}

category.Name = "Experimental"

category.CanAccess = function(client)
    return client.Character and not client.Character.IsDead and not client.Character.HasJob("convict")
end

category.Products = {
    {
        Name = "Door",
        Price = 400,
        Limit = 4,
        Items = {
            {Identifier = "door", IsInstallation = true}
        }
    },

    {
        Name = "Hatch",
        Price = 400,
        Limit = 4,
        Items = {
            {Identifier = "hatch", IsInstallation = true}
        }
    },

    {
        Name = "Supplies Cabinet",
        Price = 100,
        Limit = 6,
        Items = {
            {Identifier = "suppliescabinet", IsInstallation = true}
        }
    },

    {
        Name = "Oxygen Generator",
        Price = 200,
        Limit = 6,
        Items = {
            {Identifier = "shuttleoxygenerator", IsInstallation = true}
        }
    },

    {
        Name = "Fabricator",
        Price = 230,
        Limit = 4,
        Items = {
            {Identifier = "fabricator", IsInstallation = true}
        }
    },

    {
        Name = "Deconstructor",
        Price = 235,
        Limit = 4,
        Items = {
            {Identifier = "deconstructor", IsInstallation = true}
        }
    },

    {
        Name = "Medical Fabricator",
        Price = 300,
        Limit = 4,
        Items = {
            {Identifier = "medicalfabricator", IsInstallation = true}
        }
    },

    {
        Name = "Research Station",
        Price = 290,
        Limit = 4,
        Items = {
            {Identifier = "op_researchterminal", IsInstallation = true}
        }
    },

    {
        Name = "Junction Box",
        Price = 180,
        Limit = 8,
        Items = {
            {Identifier = "junctionbox", IsInstallation = true}
        }
    },

    {
        Name = "Battery",
        Price = 300,
        Limit = 6,
        Items = {
            {Identifier = "battery", IsInstallation = true}
        }
    },

    {
        Name = "Super Capacitor",
        Price = 300,
        Limit = 4,
        Items = {
            {Identifier = "supercapacitor", IsInstallation = true}
        }
    },

    {
        Name = "Shuttle Engine",
        Price = 400,
        Limit = 3,
        Items = {
            {Identifier = "shuttleengine", IsInstallation = true}
        }
    },

    {
        Name = "Small Pump",
        Price = 300,
        Limit = 3,
        Items = {
            {Identifier = "smallpump", IsInstallation = true}
        }
    },

    {
        Name = "Nuclear Reactor",
        Price = 1500,
        Limit = 1,
        Items = {
            {Identifier = "reactor1", IsInstallation = true}
        }
    },

    {
        Name = "Navigation Terminal",
        Price = 370,
        Limit = 2,
        Items = {
            {Identifier = "navterminal", IsInstallation = true}
        }
    },

    {
        Name = "Camera",
        Price = 110,
        Limit = 5,
        Items = {
            {Identifier = "camera", IsInstallation = true}
        }
    },

    {
        Name = "Periscope",
        Price = 180,
        Limit = 5,
        Items = {
            {Identifier = "periscope", IsInstallation = true}
        }
    },

    {
        Name = "Lamp",
        Price = 50,
        Limit = 5,
        Items = {
            {Identifier = "lamp", IsInstallation = true}
        },
        Action = function (client, product, items)
            for key, value in pairs(items) do
                value.GetComponentString("LightComponent").IsOn = true
            end
        end
    },

    {
        Name = "Chair",
        Price = 25,
        Limit = 5,
        Items = {
            {Identifier = "opdeco_officechair", IsInstallation = true}
        },
    },

    {
        Name = "Bunk Beds",
        Price = 50,
        Limit = 5,
        Items = {
            {Identifier = "opdeco_bunkbeds", IsInstallation = true}
        },
    },

    {
        Name = "Wire",
        Price = 40,
        Limit = 8,
        Items = {
            {Identifier = "wire"}
        },
    },
}

return categorylocal gm = {}

gm.Name = "Gamemode"

function gm:Start()

end

function gm:Think()

end

function gm:End()

end

function gm:TraitorResults()

end

function gm:RoundSummary()
    local sb = Traitormod.StringBuilder:new()

    sb("Gamemode: %s\n", self.Name)

    for character, role in pairs(Traitormod.RoleManager.RoundRoles) do
        sb("\n%s\n", role:OtherGreet())
    end

    return sb:concat()
end

function gm:new(o)
    o = o or {}
    setmetatable(o, self)
    self.__index = self

    return o
end

return gm
local gr = {}

local config = Traitormod.Config.GhostRoleConfig

local ghostRolesAnnounceTimer = 0

gr.Roles = {}
gr.Characters = {}

gr.Ask = function (name, callback, character)
    if not config.Enabled then return false end

    name = string.lower(name)
    gr.Roles[name] = {Callback = callback, Taken = false, Character = character}

    local text = "[Ghost Role] New ghost role available: %s (type in chat ‖color:gui.orange‖!ghostrole %s‖color:end‖ to accept)"

    text = string.format(text, name, name)

    for key, client in pairs(Client.ClientList) do
        if client.Character == nil or client.Character.IsDead then
            local chatMessage = ChatMessage.Create("Ghost Roles", text, ChatMessageType.Default, nil, nil)
            chatMessage.Color = Color(255, 100, 10, 255)
            Game.SendDirectChatMessage(chatMessage, client)
        end
    end

    if character then
        gr.Characters[character] = name
    end

    ghostRolesAnnounceTimer = Timer.GetTime() + 80
end

gr.IsGhostRole = function (character)
    if character == nil then return false end

    if gr.Characters[character] and gr.Roles[gr.Characters[character]] then
        return true
    end

    return false
end

gr.ReturnGhostRole = function (character)
    if character == nil then return false end

    if gr.Characters[character] and gr.Roles[gr.Characters[character]] then
        gr.Roles[gr.Characters[character]].Taken = false

        return true
    end

    return false
end

Traitormod.AddCommand({"!ghostrole", "!ghostroles"}, function(client, args)
    if not config.Enabled then
        Traitormod.SendMessage(client, "Ghost roles are disabled.")
        return true
    end

    if client.Character ~= nil and not client.Character.IsDead then
        Traitormod.SendMessage(client, "Only spectators can use ghost roles.")
        return true
    end

    if not client.InGame then
        Traitormod.SendMessage(client, "You must be in game to use ghost roles.")
        return true
    end

    local name = table.concat(args, " ")
    name = string.lower(name)

    if gr.Roles[name] == nil then
        local roles = ""
        for key, value in pairs(gr.Roles) do
            if value.Character and value.Character.IsDead then
                roles = roles .. key .. "(Dead)\n"
            elseif value.Taken then
                roles = roles .. key .. "(Already Taken)\n"
            else
                roles = roles .. key .. "\n"
            end
        end

        if roles == "" then roles = "None" end

        Traitormod.SendMessage(client, "Ghost role not found, did you type the name correctly? Available roles: \n\n" .. roles)
        return true
    end

    if gr.Roles[name].Taken then
        Traitormod.SendMessage(client, "Someone already took this ghost role.")
        return true
    end

    if gr.Roles[name].Character and gr.Roles[name].Character.IsDead then
        Traitormod.SendMessage(client, "Seems this ghost role is already dead, too bad!")
        return true
    end

    Traitormod.Log(Traitormod.ClientLogName(client) .. " took the ghost role of " .. name .. ".")

    gr.Roles[name].Callback(client)
    gr.Roles[name].Taken = true

    return true
end)


Hook.Add("think", "Traitormod.GhostRoles.Think", function (...)
    if not config.Enabled then return end
    if Timer.GetTime() < ghostRolesAnnounceTimer then return end
    ghostRolesAnnounceTimer = Timer.GetTime() + 200

    local roles = ""
    for key, value in pairs(gr.Roles) do
        if not value.Taken and (not value.Character or not value.Character.IsDead) then
            roles = roles .. "\"‖color:gui.orange‖" .. key .. "\"‖color:end‖ "
        end
    end

    if roles == "" then return end

    for key, client in pairs(Client.ClientList) do
        if client.Character == nil or client.Character.IsDead then
            local chatMessage = ChatMessage.Create("Ghost Roles", "Ghost roles available: " .. roles .. "\n\nUse !ghostrole name to pick a role.", ChatMessageType.Default, nil, nil)
            chatMessage.Color = Color(255, 100, 10, 255)
            Game.SendDirectChatMessage(chatMessage, client)
        end
    end
end)

Hook.Add("roundEnd", "TraitorMod.GhostRoles.RoundEnd", function ()
    gr.Roles = {}
    gr.Characters = {}
end)

return grlocal objective = Traitormod.RoleManager.Objectives.Objective:new()

objective.Name = "Husk"
objective.AmountPoints = 800

function objective:Start(target)
    self.Target = target

    if self.Target == nil then
        return false
    end

    self.TargetName = Traitormod.GetJobString(self.Target) .. " " .. self.Target.Name

    self.Text = string.format("Turn %s into a full husk.", self.TargetName)

    return true
end

function objective:IsCompleted()
    if self.Target == nil then
        return false
    end

    local aff = self.Target.CharacterHealth.GetAffliction("huskinfection", true)

    if aff ~= nil and aff.Strength > 80 then
        return true
    end

    return false
end

function objective:IsFailed()
    if self.Target == nil then
        return false
    end

    if self.Target.IsDead then
        return true
    end

    return false
end

return objective
local role = Traitormod.RoleManager.Roles.Antagonist:new()

role.Name = "HuskServant"
role.IsAntagonist = false

function role:Start()
    local text = self:Greet()
    local client = Traitormod.FindClientCharacter(self.Character)
    if client then
        Traitormod.SendTraitorMessageBox(client, text, "oneofus")
        Traitormod.UpdateVanillaTraitor(client, true, text, "oneofus")
    end
end

function role:Greet()
    local partners = Traitormod.StringBuilder:new()
    local traitors = Traitormod.RoleManager.FindCharactersByRole("Cultist")
    for _, character in pairs(traitors) do
        if character ~= self.Character then
            partners('"%s" ', character.Name)
        end
    end
    partners = partners:concat(" ")

    local sb = Traitormod.StringBuilder:new()
    sb("You are now a Husk Servant!\nYou directly follow orders made by the Husk Cultists.\n")

    sb("Husk Cultists: %s\n", partners)

    if self.TraitorBroadcast then
        sb("\n\nYou cannot speak, but you can use !tc to communicate with the Husk Cultists.")
    end

    return sb:concat()
end

function role:OtherGreet()
    local sb = Traitormod.StringBuilder:new()
    sb("Husk Servant %s.", self.Character.Name)
    return sb:concat()
end

return role
if CLIENT then return end

Traitormod = {}
Traitormod.VERSION = "2.4.3"

print(">> Traitor Mod v" .. Traitormod.VERSION)
print(">> Github Contributors: evilfactory, MassCraxx, Philly-V, Qunk1, mc-oofert.")
print(">> Special thanks to Qunk, Femboy69 and JoneK for helping in the development of this mod.")

local path = table.pack(...)[1]

Traitormod.Path = path

dofile(Traitormod.Path .. "/Lua/traitormod.lua")--
-- json.lua
--
-- Copyright (c) 2020 rxi
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of
-- this software and associated documentation files (the "Software"), to deal in
-- the Software without restriction, including without limitation the rights to
-- use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
-- of the Software, and to permit persons to whom the Software is furnished to do
-- so, subject to the following conditions:
--
-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.
--

local json = { _version = "0.1.2" }

-------------------------------------------------------------------------------
-- Encode
-------------------------------------------------------------------------------

local encode

local escape_char_map = {
  [ "\\" ] = "\\",
  [ "\"" ] = "\"",
  [ "\b" ] = "b",
  [ "\f" ] = "f",
  [ "\n" ] = "n",
  [ "\r" ] = "r",
  [ "\t" ] = "t",
}

local escape_char_map_inv = { [ "/" ] = "/" }
for k, v in pairs(escape_char_map) do
  escape_char_map_inv[v] = k
end


local function escape_char(c)
  return "\\" .. (escape_char_map[c] or string.format("u%04x", c:byte()))
end


local function encode_nil(val)
  return "null"
end


local function encode_table(val, stack)
  local res = {}
  stack = stack or {}

  -- Circular reference?
  if stack[val] then error("circular reference") end

  stack[val] = true

  if rawget(val, 1) ~= nil or next(val) == nil then
    -- Treat as array -- check keys are valid and it is not sparse
    local n = 0
    for k in pairs(val) do
      if type(k) ~= "number" then
        error("invalid table: mixed or invalid key types")
      end
      n = n + 1
    end
    if n ~= #val then
      error("invalid table: sparse array")
    end
    -- Encode
    for i, v in ipairs(val) do
      table.insert(res, encode(v, stack))
    end
    stack[val] = nil
    return "[" .. table.concat(res, ",") .. "]"

  else
    -- Treat as an object
    for k, v in pairs(val) do
      if type(k) ~= "string" then
        error("invalid table: mixed or invalid key types")
      end
      table.insert(res, encode(k, stack) .. ":" .. encode(v, stack))
    end
    stack[val] = nil
    return "{" .. table.concat(res, ",") .. "}"
  end
end


local function encode_string(val)
  return '"' .. val:gsub('[%z\1-\31\\"]', escape_char) .. '"'
end


local function encode_number(val)
  -- Check for NaN, -inf and inf
  if val ~= val or val <= -math.huge or val >= math.huge then
    error("unexpected number value '" .. tostring(val) .. "'")
  end
  return string.format("%.14g", val)
end


local type_func_map = {
  [ "nil"     ] = encode_nil,
  [ "table"   ] = encode_table,
  [ "string"  ] = encode_string,
  [ "number"  ] = encode_number,
  [ "boolean" ] = tostring,
}


encode = function(val, stack)
  local t = type(val)
  local f = type_func_map[t]
  if f then
    return f(val, stack)
  end
  error("unexpected type '" .. t .. "'")
end


function json.encode(val)
  return ( encode(val) )
end


-------------------------------------------------------------------------------
-- Decode
-------------------------------------------------------------------------------

local parse

local function create_set(...)
  local res = {}
  for i = 1, select("#", ...) do
    res[ select(i, ...) ] = true
  end
  return res
end

local space_chars   = create_set(" ", "\t", "\r", "\n")
local delim_chars   = create_set(" ", "\t", "\r", "\n", "]", "}", ",")
local escape_chars  = create_set("\\", "/", '"', "b", "f", "n", "r", "t", "u")
local literals      = create_set("true", "false", "null")

local literal_map = {
  [ "true"  ] = true,
  [ "false" ] = false,
  [ "null"  ] = nil,
}


local function next_char(str, idx, set, negate)
  for i = idx, #str do
    if set[str:sub(i, i)] ~= negate then
      return i
    end
  end
  return #str + 1
end


local function decode_error(str, idx, msg)
  local line_count = 1
  local col_count = 1
  for i = 1, idx - 1 do
    col_count = col_count + 1
    if str:sub(i, i) == "\n" then
      line_count = line_count + 1
      col_count = 1
    end
  end
  error( string.format("%s at line %d col %d", msg, line_count, col_count) )
end


local function codepoint_to_utf8(n)
  -- http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&id=iws-appendixa
  local f = math.floor
  if n <= 0x7f then
    return string.char(n)
  elseif n <= 0x7ff then
    return string.char(f(n / 64) + 192, n % 64 + 128)
  elseif n <= 0xffff then
    return string.char(f(n / 4096) + 224, f(n % 4096 / 64) + 128, n % 64 + 128)
  elseif n <= 0x10ffff then
    return string.char(f(n / 262144) + 240, f(n % 262144 / 4096) + 128,
                       f(n % 4096 / 64) + 128, n % 64 + 128)
  end
  error( string.format("invalid unicode codepoint '%x'", n) )
end


local function parse_unicode_escape(s)
  local n1 = tonumber( s:sub(1, 4),  16 )
  local n2 = tonumber( s:sub(7, 10), 16 )
   -- Surrogate pair?
  if n2 then
    return codepoint_to_utf8((n1 - 0xd800) * 0x400 + (n2 - 0xdc00) + 0x10000)
  else
    return codepoint_to_utf8(n1)
  end
end


local function parse_string(str, i)
  local res = ""
  local j = i + 1
  local k = j

  while j <= #str do
    local x = str:byte(j)

    if x < 32 then
      decode_error(str, j, "control character in string")

    elseif x == 92 then -- `\`: Escape
      res = res .. str:sub(k, j - 1)
      j = j + 1
      local c = str:sub(j, j)
      if c == "u" then
        local hex = str:match("^[dD][89aAbB]%x%x\\u%x%x%x%x", j + 1)
                 or str:match("^%x%x%x%x", j + 1)
                 or decode_error(str, j - 1, "invalid unicode escape in string")
        res = res .. parse_unicode_escape(hex)
        j = j + #hex
      else
        if not escape_chars[c] then
          decode_error(str, j - 1, "invalid escape char '" .. c .. "' in string")
        end
        res = res .. escape_char_map_inv[c]
      end
      k = j + 1

    elseif x == 34 then -- `"`: End of string
      res = res .. str:sub(k, j - 1)
      return res, j + 1
    end

    j = j + 1
  end

  decode_error(str, i, "expected closing quote for string")
end


local function parse_number(str, i)
  local x = next_char(str, i, delim_chars)
  local s = str:sub(i, x - 1)
  local n = tonumber(s)
  if not n then
    decode_error(str, i, "invalid number '" .. s .. "'")
  end
  return n, x
end


local function parse_literal(str, i)
  local x = next_char(str, i, delim_chars)
  local word = str:sub(i, x - 1)
  if not literals[word] then
    decode_error(str, i, "invalid literal '" .. word .. "'")
  end
  return literal_map[word], x
end


local function parse_array(str, i)
  local res = {}
  local n = 1
  i = i + 1
  while 1 do
    local x
    i = next_char(str, i, space_chars, true)
    -- Empty / end of array?
    if str:sub(i, i) == "]" then
      i = i + 1
      break
    end
    -- Read token
    x, i = parse(str, i)
    res[n] = x
    n = n + 1
    -- Next token
    i = next_char(str, i, space_chars, true)
    local chr = str:sub(i, i)
    i = i + 1
    if chr == "]" then break end
    if chr ~= "," then decode_error(str, i, "expected ']' or ','") end
  end
  return res, i
end


local function parse_object(str, i)
  local res = {}
  i = i + 1
  while 1 do
    local key, val
    i = next_char(str, i, space_chars, true)
    -- Empty / end of object?
    if str:sub(i, i) == "}" then
      i = i + 1
      break
    end
    -- Read key
    if str:sub(i, i) ~= '"' then
      decode_error(str, i, "expected string for key")
    end
    key, i = parse(str, i)
    -- Read ':' delimiter
    i = next_char(str, i, space_chars, true)
    if str:sub(i, i) ~= ":" then
      decode_error(str, i, "expected ':' after key")
    end
    i = next_char(str, i + 1, space_chars, true)
    -- Read value
    val, i = parse(str, i)
    -- Set
    res[key] = val
    -- Next token
    i = next_char(str, i, space_chars, true)
    local chr = str:sub(i, i)
    i = i + 1
    if chr == "}" then break end
    if chr ~= "," then decode_error(str, i, "expected '}' or ','") end
  end
  return res, i
end


local char_func_map = {
  [ '"' ] = parse_string,
  [ "0" ] = parse_number,
  [ "1" ] = parse_number,
  [ "2" ] = parse_number,
  [ "3" ] = parse_number,
  [ "4" ] = parse_number,
  [ "5" ] = parse_number,
  [ "6" ] = parse_number,
  [ "7" ] = parse_number,
  [ "8" ] = parse_number,
  [ "9" ] = parse_number,
  [ "-" ] = parse_number,
  [ "t" ] = parse_literal,
  [ "f" ] = parse_literal,
  [ "n" ] = parse_literal,
  [ "[" ] = parse_array,
  [ "{" ] = parse_object,
}


parse = function(str, idx)
  local chr = str:sub(idx, idx)
  local f = char_func_map[chr]
  if f then
    return f(str, idx)
  end
  decode_error(str, idx, "unexpected character '" .. chr .. "'")
end


function json.decode(str)
  if type(str) ~= "string" then
    error("expected argument of type string, got " .. type(str))
  end
  local res, idx = parse(str, next_char(str, 1, space_chars, true))
  idx = next_char(str, idx, space_chars, true)
  if idx <= #str then
    decode_error(str, idx, "trailing garbage")
  end
  return res
end


return jsonlocal objective = Traitormod.RoleManager.Objectives.Objective:new()

objective.Name = "Kidnap"
objective.AmountPoints = 2500

function objective:Start(target)
    self.Target = target

    if self.Target == nil then
        return false
    end

    self.TargetName = Traitormod.GetJobString(target) .. " " .. target.Name

    self.Text = string.format(Traitormod.Language.ObjectiveKidnap, self.TargetName,
    self.Seconds)

    self.SecondsLeft = self.Seconds

    return true
end

function objective:IsCompleted()
    if self.SecondsLeft <= 0 then
        self.Text = string.format(Traitormod.Language.ObjectiveKidnap, self.TargetName,
        self.Seconds)

        return true
    end

    local char = self.Target

    if char == nil or char.IsDead then return false end

    local item = char.Inventory.GetItemInLimbSlot(InvSlotType.RightHand)

    if item ~= nil and item.Prefab.Identifier == "handcuffs" then
        if self.lastTimer == nil then
            self.lastTimer = Timer.GetTime()
        end

        self.SecondsLeft = math.max(0, self.SecondsLeft - (Timer.GetTime() - self.lastTimer))

        self.Text = string.format(Traitormod.Language.ObjectiveKidnap, self.TargetName,
            math.floor(self.SecondsLeft))

        self.lastTimer = Timer.GetTime()

    else
        self.lastTimer = Timer.GetTime()
    end

    return false
end

return objective
local objective = Traitormod.RoleManager.Objectives.Objective:new()

objective.Name = "KillMonsters"
objective.AmountPoints = 400
objective.Monsters = {
    ["Crawler"] = {
        Text = "Crawlers",
        Amount = 20,
    },

    ["Hammerhead"] = {
        Text = "Hammerheads",
        Amount = 2,
    },

    ["Mudraptor"] = {
        Text = "Mudraptors",
        Amount = 2,
    },
}

function objective:Start(target)
    local types = {}
    for key, value in pairs(self.Monsters) do
        table.insert(types, key)
    end
    self.Type = types[math.random(1, #types)]

    self.Text = string.format("Kill %s %s.", self.Monsters[self.Type].Amount, self.Monsters[self.Type].Text)

    self.Progress = 0

    return true
end

function objective:CharacterDeath(character)
    if character.SpeciesName.Value == self.Type then
        if character.CauseOfDeath and character.CauseOfDeath.Killer == self.Character then
            self.Progress = self.Progress + 1
            self.Text = string.format("Kill (%s/%s) %s.", self.Progress, self.Monsters[self.Type].Amount, self.Monsters[self.Type].Text)
        end
    end
end

function objective:IsCompleted()
    if self.Progress >= self.Monsters[self.Type].Amount then
        return true
    end

    return false
end

return objective
local event = {}

event.Name = "LightsOff"
event.MinRoundTime = 15
event.MinIntensity = 0
event.MaxIntensity = 0.1
event.ChancePerMinute = 0.0005
event.OnlyOncePerRound = true

event.Time = 3

event.ColorsToRevert = {}

event.Start = function ()
    for k, v in pairs(Submarine.MainSub.GetItems(true)) do
        local c = v.GetComponentString('LightComponent')
        if c and not v.Prefab.CanBeBought then
            Timer.Wait(function ()
                event.ColorsToRevert[v] = c.LightColor
                c.LightColor = Color(0, 0, 0, 128)
                local prop = c.SerializableProperties[Identifier("LightColor")]
                Networking.CreateEntityEvent(v, Item.ChangePropertyEventData(prop, c))    
            end, math.random(1000, 5000))
        end
    end

    Timer.Wait(function ()
        local text = "All lights suddenly turn off, but power is still on? What's going on?"
        Traitormod.RoundEvents.SendEventMessage(text, "EyeButton")     
    end, 6000)

    Timer.Wait(event.End, event.Time * 60000)
end


event.End = function ()
    for k, v in pairs(event.ColorsToRevert) do
        Timer.Wait(function ()
            local c = k.GetComponentString('LightComponent')
            c.LightColor = v
            local prop = c.SerializableProperties[Identifier("LightColor")]
            Networking.CreateEntityEvent(k, Item.ChangePropertyEventData(prop, c))
        end, math.random(1000, 5000))

        event.ColorsToRevert[k] = nil
    end
end

return eventlocal category = {}

category.Name = "Maintenance"

category.CanAccess = function(client)
    return client.Character and not client.Character.IsDead and not client.Character.HasJob("convict")
end

category.Products = {
    {
        Name = "Screwdriver",
        Price = 90,
        Limit = 1,
        Items = {"screwdriver"}
    },

    {
        Name = "Wrench",
        Price = 90,
        Limit = 1,
        Items = {"wrench"}
    },

    {
        Name = "Welding Tool",
        Price = 160,
        Limit = 4,
        Items = {"weldingtool", "weldingfueltank"}
    },

    {
        Name = "Fixfoam Grenade",
        Price = 190,
        Limit = 4,
        Items = {"fixfoamgrenade", "fixfoamgrenade"}
    },

    {
        Name = "Repair Pack",
        Price = 140,
        Limit = 4,
        Items = {"repairpack", "repairpack", "repairpack", "repairpack"}
    },

    {
        Name = "Low Quality Fuel Rod",
        Price = 260,
        Limit = 10,

        Items = {{Identifier = "fuelrod", Condition = 9}},
    },
}

return categorylocal event = {}

event.Name = "MaintenanceToolsDelivery"
event.MinRoundTime = 5
event.MinIntensity = 0.6
event.MaxIntensity = 1
event.ChancePerMinute = 0.03
event.OnlyOncePerRound = false

local cratePrefab = ItemPrefab.GetItemPrefab("metalcrate")
local items = {"fixfoamgrenade", "fixfoamgrenade", "fixfoamgrenade", "fixfoamgrenade", "fixfoamgrenade", "fixfoamgrenade", "fixfoamgrenade", "fixfoamgrenade", "repairpack", "repairpack", "repairpack", "repairpack", "repairpack", "repairpack", "repairpack", "repairpack", "weldingtool", "weldingfueltank"}

event.Start = function ()
    local position = nil

    for key, value in pairs(Submarine.MainSub.GetWaypoints(true)) do
        if value.SpawnType == SpawnType.Cargo then
            position = value.WorldPosition
            break
        end
    end

    if position == nil then
        position = Submarine.MainSub.WorldPosition
    end

    Entity.Spawner.AddItemToSpawnQueue(cratePrefab, position, nil, nil, function(item)
        item.SpriteColor = Color(255, 255, 0, 255)
        local property = item.SerializableProperties[Identifier("SpriteColor")]
        Networking.CreateEntityEvent(item, Item.ChangePropertyEventData(property, item))

        for key, value in pairs(items) do
            Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab(value), item.OwnInventory)
        end
    end)

    local text = "A delivery of maintenance tools has been made into the cargo area of the ship. The supplies are inside a yellow crate."
    Traitormod.RoundEvents.SendEventMessage(text, "GameModeIcon.sandbox")

    event.End()
end


event.End = function ()

end

return eventlocal event = {}

event.Name = "MedicalDelivery"
event.MinRoundTime = 5
event.MinIntensity = 0.6
event.MaxIntensity = 1
event.ChancePerMinute = 0.03
event.OnlyOncePerRound = false

local cratePrefab = ItemPrefab.GetItemPrefab("mediccrate")
local items = {"antibleeding1", "antibleeding1", "antibleeding1", "antibleeding1","antibleeding1", "antibleeding1", "antibleeding2", "antibleeding2", "antibloodloss1", "antibloodloss1", "antibloodloss1", "alienblood", "alienblood", "alienblood", "antidama1", "antidama1", "antidama1", "stabilozine", "stabilozine", "stabilozine", "stabilozine", "stabilozine", "stabilozine", "stabilozine","stabilozine", "ethanol", "ethanol", "antibiotics", "calyxanide", "calyxanide", "energydrink", "energydrink", "proteinbar", "proteinbar"}

event.Start = function ()
    local position = nil

    for key, value in pairs(Submarine.MainSub.GetWaypoints(true)) do
        if value.AssignedJob and value.AssignedJob.Identifier == "medicaldoctor" then
            position = value.WorldPosition
            break
        end
    end

    if position == nil then
        position = Submarine.MainSub.WorldPosition
    end

    Entity.Spawner.AddItemToSpawnQueue(cratePrefab, position, nil, nil, function(item)
        item.SpriteColor = Color(255, 0, 0, 255)
        local property = item.SerializableProperties[Identifier("SpriteColor")]
        Networking.CreateEntityEvent(item, Item.ChangePropertyEventData(property, item))

        for key, value in pairs(items) do
            Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab(value), item.OwnInventory)
        end
    end)

    local text = "A medical delivery has been made into the medical area of the ship. The medical supplies are inside a red medical crate."
    Traitormod.RoundEvents.SendEventMessage(text, "GameModeIcon.sandbox")

    event.End()
end


event.End = function ()

end

return event-- MidRoundSpawn v9 - offers newly joined players the option to spawn mid-round
-- by MassCraxx

if CLIENT then return end

-- CONFIG
local CheckDelaySeconds = 10
local SpawnDelaySeconds = 0
local GiveSpectatorsSpawnOption = false   -- if true, spectating players will be given the option to mid-round spawn
local PreventMultiCaptain = true          -- if true, will give securityofficer job to players trying to spawn as additional captain

local CheckTime = -1
local HasBeenSpawned = {}
local NewPlayers = {}

MidRoundSpawn = {}
MidRoundSpawn.Log = function (message)
    Game.Log("[MidRoundSpawn] " .. message, 6)
end

MidRoundSpawn.SpawnClientCharacterOnSub = function(client)
    if not Game.RoundStarted or not client.InGame then return false end 

    local spawned = MidRoundSpawn.TryCreateClientCharacter(client)
    HasBeenSpawned[client.SteamID] = spawned

    return spawned
end

MidRoundSpawn.CrewHasJob = function(job)
    if #Client.ClientList > 1 then
        for key, value in pairs(Client.ClientList) do
            if value.Character and value.Character.HasJob(job) then return true end
        end
    end
    return false
end

MidRoundSpawn.GetJobVariant = function(jobId)
    local prefab = JobPrefab.Get(jobId)
    return JobVariant.__new(prefab, 0)
end

-- TryCreateClientCharacter inspied by Oiltanker
MidRoundSpawn.TryCreateClientCharacter = function(client)
    local session = Game.GameSession
    local crewManager = session.CrewManager

    -- fix client char info
    if client.CharacterInfo == nil then client.CharacterInfo = CharacterInfo.__new('human', client.Name) end

    local jobPreference = client.JobPreferences[1]

    if jobPreference == nil then
        -- if no jobPreference, set assistant
        jobPreference = MidRoundSpawn.GetJobVariant("assistant")

    elseif PreventMultiCaptain and jobPreference.Prefab.Identifier == "warden" or jobPreference.Prefab.Identifier == "headguard" then
        -- if crew has a captain, spawn as security
        if MidRoundSpawn.CrewHasJob("warden") or MidRoundSpawn.CrewHasJob("headguard") then
            MidRoundSpawn.Log(client.Name .. " tried to mid-round spawn as second captain - assigning security instead.")
            -- set jobPreference = security
            jobPreference = MidRoundSpawn.GetJobVariant("convict")
        end
    end

    client.AssignedJob = jobPreference
    client.CharacterInfo.Job = Job.__new(jobPreference.Prefab, 0, jobPreference.Variant);

    crewManager.AddCharacterInfo(client.CharacterInfo)

    local spawnWayPoints = WayPoint.SelectCrewSpawnPoints({client.CharacterInfo}, Submarine.MainSub)
    local randomIndex = Random.Range(1, #spawnWayPoints)
    local waypoint = spawnWayPoints[randomIndex]

    -- find waypoint the hard way
    if waypoint == nil then
        for i,wp in pairs(WayPoint.WayPointList) do
            if
                wp.AssignedJob ~= nil and
                wp.SpawnType == SpawnType.Human and
                wp.Submarine == Submarine.MainSub and
                wp.CurrentHull ~= nil
            then
                if client.CharacterInfo.Job.Prefab == wp.AssignedJob then
                    waypoint = wp
                    break
                end
            end
        end
    end

    -- none found, go random
    if waypoint == nil then 
        MidRoundSpawn.Log("WARN: No valid job waypoint found for " .. client.CharacterInfo.Job.Name.Value .. " - using random")
        waypoint = WayPoint.GetRandom(SpawnType.Human, nil, Submarine.MainSub)
    end

    if waypoint == nil then 
        MidRoundSpawn.Log("ERROR: Could not spawn player - no valid waypoint found")
        return false 
    end

    MidRoundSpawn.Log("Spawning " .. client.Name .. " as " .. client.CharacterInfo.Job.Name.Value)

    Timer.Wait(function () 
        -- spawn character
        local char = Character.Create(client.CharacterInfo, waypoint.WorldPosition, client.CharacterInfo.Name, 0, true, true);
        char.TeamID = CharacterTeamType.FriendlyNPC;
        crewManager.AddCharacter(char)

        client.SetClientCharacter(char)
        --mcm_client_manager:set(client, char)
        
        char.GiveJobItems(waypoint)
        char.LoadTalents()
        char.GiveIdCardTags(waypoint, false)
    end, SpawnDelaySeconds * 1000)
    return true
end

MidRoundSpawn.CreateDialog = function()
    local c = {}

    local promptIDToCallback = {}

    local function SendEventMessage(msg, options, id, eventSprite, fadeToBlack, client)
        local message = Networking.Start()
        message.WriteByte(Byte(18)) -- net header
        message.WriteByte(Byte(0)) -- conversation
    
        message.WriteUInt16(UShort(id)) -- ushort identifier 0
        message.WriteString(eventSprite) -- event sprite
        message.WriteByte(Byte(0)) -- dialog Type
        message.WriteBoolean(false) -- continue conversation
    
        message.WriteUInt16(UShort(0)) -- speak Id
        message.WriteString(msg)
        message.WriteBoolean(fadeToBlack or false) -- fade to black
        message.WriteByte(Byte(#options))
        for key, value in pairs(options) do
            message.WriteString(value)
        end
        message.WriteByte(Byte(#options))
        for i = 0, #options - 1, 1 do
            message.WriteByte(Byte(i))
        end

        Networking.Send(message, client.Connection, DeliveryMethod.Reliable)
    end


    Hook.Add("netMessageReceived", "MidRoundSpawn.promptResponse", function (msg, header, client)
        if header == ClientPacketHeader.EVENTMANAGER_RESPONSE then 
            local id = msg.ReadUInt16()
            local option = msg.ReadByte()

            if promptIDToCallback[id] ~= nil then
                promptIDToCallback[id](option, client)
            end
            msg.BitPosition = msg.BitPosition - (8 * 3) -- rewind 3 bytes from the message, so it can be read again
        end
    end)

    c.Prompt = function (message, options, client, callback, eventSprite)
        local currentPromptID = math.floor(math.random(0,65535))

        promptIDToCallback[currentPromptID] = callback
        SendEventMessage(message, options, currentPromptID, eventSprite, false, client)
    end

    return c
end

MidRoundSpawn.ShowSpawnDialog = function(client, force)
    if not force and client.Character and not client.Character.IsDead then
        MidRoundSpawn.Log(client.Name .. " was prevented to midroundspawn due to having an alive character.")
        return
    end
    local dialog = MidRoundSpawn.CreateDialog()
    dialog.Prompt("Do you want to spawn instantly or wait for the next respawn?\n", {"> Spawn", "> Wait"}, client, function(option, client) 
        if option == 0 then
            if force or not client.Character or client.Character.IsDead then
                MidRoundSpawn.SpawnClientCharacterOnSub(client)
            else
                MidRoundSpawn.Log(client.Name .. " attempted midroundspawn while having alive character.")
            end
        end
    end)
end

Hook.Add("roundStart", "MidRoundSpawn.roundStart", function ()
    -- Reset tables
    HasBeenSpawned = {}
    NewPlayers = {}

    -- Flag all lobby players as spawned
    for key, client in pairs(Client.ClientList) do
        if not client.SpectateOnly then
            HasBeenSpawned[client.SteamID] = true
        else
            MidRoundSpawn.Log(client.Name .. " is spectating.")
        end
    end
end)

Hook.Add("clientConnected", "MidRoundSpawn.clientConnected", function (newClient)
    -- client connects, round has started and client has not been considered for spawning yet
    if not Game.RoundStarted or HasBeenSpawned[newClient.SteamID] then return end

    if newClient.InGame then
        -- if client for some reason is already InGame (lobby skip?) spawn
        MidRoundSpawn.SpawnClientCharacterOnSub(newClient)
    else
        -- else store for later spawn 
        MidRoundSpawn.Log("Adding new player to spawn list: " .. newClient.Name)
        table.insert(NewPlayers, newClient)

        -- inform player about his luck
        Game.SendDirectChatMessage("", ">> MidRoundSpawn active! <<\nThe round has already started, but you can spawn instantly!", nil, ChatMessageType.Private, newClient)
    end
end)

Hook.Add("think", "MidRoundSpawn.think", function ()
    if Game.RoundStarted and CheckTime and Timer.GetTime() > CheckTime then
        CheckTime = Timer.GetTime() + CheckDelaySeconds
        
        -- check all NewPlayers and if not spawned already and inGame spawn
        for i = #NewPlayers, 1, -1 do
            local newClient = NewPlayers[i]
            
            -- if client still valid and not spawned yet, no spectator and has an active connection
            if newClient and not HasBeenSpawned[newClient.SteamID] and (GiveSpectatorsSpawnOption or not newClient.SpectateOnly) and newClient.Connection and newClient.Connection.Status == 1 then
                -- wait for client to be ingame, then cpasn
                if newClient.InGame then
                    MidRoundSpawn.ShowSpawnDialog(newClient)
                    table.remove(NewPlayers, i)
                --else
                    --MidRoundSpawn.Log(newClient.Name .. " waiting in lobby...")
                end
            else
                if (not GiveSpectatorsSpawnOption and newClient.SpectateOnly) then
                    MidRoundSpawn.Log("Removing spectator from spawn list: " .. newClient.Name)
                else
                    MidRoundSpawn.Log("Removing invalid player from spawn list: " .. newClient.Name)
                end
                table.remove(NewPlayers, i)
            end
        end
    end
end)

-- Commands hook
Hook.Add("chatMessage", "MidRoundSpawn.ChatMessage", function (message, client)

    if message == "!midroundspawn" then
        if client.InGame then
            if (not HasBeenSpawned[client.SteamID] or client.HasPermission(ClientPermissions.ConsoleCommands)) and (not client.Character or client.Character.IsDead) then
                MidRoundSpawn.ShowSpawnDialog(client)
            else
                Game.SendDirectChatMessage("", "You spawned already.", nil, ChatMessageType.Error, client)
            end
        else
            Game.SendDirectChatMessage("", "You are not in-game.", nil, ChatMessageType.Error, client)
        end
        return true
    end
end)local objective = {}

objective.Name = "Objective"
objective.Text = "Complete the objective!"
objective.AmountPoints = 100
objective.EndRoundObjective = false
objective.DontLooseLives = false

objective.Awarded = false

function objective:Init(character)
    self.Character = character
end

function objective:Start()
    return true
end

function objective:IsCompleted()
    return true
end

function objective:CharacterDeath(character) end
function objective:StopRepairing(item, character) end

function objective:IsFailed()
    return false
end

function objective:Award()
    self.Awarded = true

    local client = Traitormod.FindClientCharacter(self.Character)

    if client then 
        local points = Traitormod.AwardPoints(client, self.AmountPoints)
        local lives = Traitormod.AdjustLives(client, self.AmountLives)
        Traitormod.SendObjectiveCompleted(client, self.Text, points, lives)

        if self.DontLooseLives then
            Traitormod.LostLivesThisRound[client.SteamID] = true
        end
    end

    if self.OnAwarded ~= nil then
        self:OnAwarded()
    end
end

function objective:Fail()
    self.Awarded = true
    
    local client = Traitormod.FindClientCharacter(self.Character)

    if client then 
        Traitormod.SendObjectiveFailed(client, self.Text)
    end

    if self.OnAwarded ~= nil then
        self:OnAwarded()
    end
end

function objective:new(o)
    o = o or {}
    setmetatable(o, self)
    self.__index = self

    return o
end

return objective
local event = {}

event.Enabled = true
event.Name = "OxygenGeneratorPoison"
event.MinRoundTime = 15
event.MinIntensity = 0
event.MaxIntensity = 0.05
event.ChancePerMinute = 0.001
event.OnlyOncePerRound = true

event.Start = function ()
    local text = "The oxygen generator has been sabotaged and is now supplying sufforin into the air, you have about 15 seconds to get a diving mask or a diving suit before you receive a high enough dose!"
    Traitormod.RoundEvents.SendEventMessage(text, "GameModeIcon.pvp", Color.Red)

    local function GivePoison(character)
        if character.Submarine ~= Submarine.MainSub then return end
        if character.IsDead then return end
        if character.IsProtectedFromPressure then return end
        local headGear = character.Inventory.GetItemInLimbSlot(InvSlotType.Head)
        if headGear ~= nil and headGear.Prefab.Identifier == "divingmask" then return end
        if headGear ~= nil and headGear.Prefab.Identifier == "clowndivingmask" then return end

        local poison = AfflictionPrefab.Prefabs["sufforinpoisoning"]
        character.CharacterHealth.ApplyAffliction(character.AnimController.MainLimb, poison.Instantiate(15))
    end


    Timer.Wait(function ()
        for key, value in pairs(Character.CharacterList) do
            GivePoison(value)
        end
    end, 20000)

    Timer.Wait(event.End, 30000)
end


event.End = function (isEndRound)
    if not isEndRound then
        local text = "The oxygen from the oxygen generator is now safe to breathe again."

        Traitormod.RoundEvents.SendEventMessage(text, "GameModeIcon.multiplayercampaign")
    end
end

return eventlocal ps = {}

local config = Traitormod.Config
local textPromptUtils = require("textpromptutils")

local defaultLimit = 999

ps.ProductBuyFailureReason = {
    NoPoints = 1,
    NoStock = 2,
}

ps.GlobalProductLimits = {}
ps.LocalProductLimits = {}
ps.Timeouts = {}

ps.ValidateConfig = function ()
    for i, category in pairs(config.PointShopConfig.ItemCategories) do
        for k, product in pairs(category.Products) do
            if product.Items then
                for z, item in pairs(product.Items) do
                    if type(item) == "string" then
                        item = {Identifier = item}
                    end

                    if type(item) ~= "table" then
                        Traitormod.Error(string.format("PointShop Error: Inside the Category \"%s\" theres a Product with Name \"%s\", that is invalid", category.Name, product.Name))
                    elseif item.Identifier == nil then
                        Traitormod.Error(string.format("PointShop Error: Inside the Category \"%s\" theres a Product with Name \"%s\", that has items without an Identifier", category.Name, product.Name))
                    elseif ItemPrefab.GetItemPrefab(item.Identifier) == nil then
                        Traitormod.Error(string.format("PointShop Error: Inside the Category \"%s\" theres a Product with Name \"%s\", that has an invalid item identifier \"%s\"", category.Name, product.Name, item.Identifier))
                    end
                end
            end
        end
    end
end

ps.ResetProductLimits = function()
    ps.GlobalProductLimits = {}
    ps.LocalProductLimits = {}
end

ps.GetProductLimit = function (client, product)
    if product.IsLimitGlobal then
        if ps.GlobalProductLimits[product.Name] == nil then
            ps.GlobalProductLimits[product.Name] = product.Limit or defaultLimit
        end

        return ps.GlobalProductLimits[product.Name]
    else
        if ps.LocalProductLimits[client.SteamID] == nil then
            ps.LocalProductLimits[client.SteamID] = {}
        end

        local localProductLimit = ps.LocalProductLimits[client.SteamID]

        if localProductLimit[product.Name] == nil then
            localProductLimit[product.Name] = product.Limit or defaultLimit
        end

        return localProductLimit[product.Name]
    end
end

ps.UseProductLimit = function (client, product)
    if product.IsLimitGlobal then
        if ps.GlobalProductLimits[product.Name] == nil then
            ps.GlobalProductLimits[product.Name] = product.Limit or defaultLimit
        end

        if ps.GlobalProductLimits[product.Name] > 0 then
            ps.GlobalProductLimits[product.Name] = ps.GlobalProductLimits[product.Name] - 1
            return true
        else
            return false
        end
    else
        if ps.LocalProductLimits[client.SteamID] == nil then
            ps.LocalProductLimits[client.SteamID] = {}
        end

        local localProductLimit = ps.LocalProductLimits[client.SteamID]

        if localProductLimit[product.Name] == nil then
            localProductLimit[product.Name] = product.Limit or defaultLimit
        end

        if localProductLimit[product.Name] > 0 then
            localProductLimit[product.Name] = localProductLimit[product.Name] - 1
            return true
        else
            return false
        end
    end
end

ps.FindProductByName = function (client, name)
    for i, category in pairs(config.PointShopConfig.ItemCategories) do
        if ps.CanClientAccessCategory(client, category) then
            for k, product in pairs(category.Products) do
                if product.Name == name then
                    return product
                end
            end
        end
    end 
end

ps.CanClientAccessCategory = function(client, category)
    if category.CanAccess ~= nil then
        return category.CanAccess(client)
    elseif client.Character == nil or client.Character.IsDead or not client.Character.IsHuman then
        return false
    end

    return true
end

ps.ValidateClient = function(client)
    if not config.PointShopConfig.Enabled then
        Traitormod.SendMessage(client, Traitormod.Language.CommandNotActive)
        return false
    end

    if not client.InGame then
        Traitormod.SendMessage(client, "You must be in game to use the Pointshop.")
        return false
    end

    return true
end

ps.SpawnItem = function(client, item, onSpawned)
    local prefab = ItemPrefab.GetItemPrefab(item.Identifier)
    local condition = item.Condition or item.MaxCondition

    if prefab == nil then
        Traitormod.SendMessage(client, "PointShop Error: Could not find item with identifier " .. item.Identifier .. " please report this error.")
        Traitormod.Error("PointShop Error: Could not find item with identifier " .. item.Identifier)
        return
    end

    local function OnSpawn(item)
        local powerContainer = item.GetComponentString("PowerContainer")
        if powerContainer then
            powerContainer.Capacity = powerContainer.Capacity * 10
            powerContainer.Charge = powerContainer.Capacity
        end

        if onSpawned then onSpawned(item) end
    end

    if item.IsInstallation then
        local position = client.Character.AnimController.GetLimb(LimbType.Torso).WorldPosition
        if client.Character.Submarine == nil then
            Entity.Spawner.AddItemToSpawnQueue(prefab, position, condition, nil, OnSpawn)
        else
            Entity.Spawner.AddItemToSpawnQueue(prefab, position - client.Character.Submarine.Position, client.Character.Submarine, condition, nil, OnSpawn)
        end
    else
        Entity.Spawner.AddItemToSpawnQueue(prefab, client.Character.Inventory, condition, nil, OnSpawn)
    end
end

ps.ActivateProduct = function (client, product)
    local spawnedItems = {}
    local spawnedItemCount = 0

    local function OnSpawned(item)
        table.insert(spawnedItems, item)

        spawnedItemCount = spawnedItemCount + 1

        if spawnedItemCount == #product.Items and product.Action then
            product.Action(client, product, spawnedItems)
        end
    end

    if product.Items then
        if product.ItemRandom then
            local randomIndex = math.random(1, #product.Items)
            local item = product.Items[randomIndex]

            if type(product.Items[randomIndex]) == "string" then
                item = {Identifier = product.Items[randomIndex]}
            end

            ps.SpawnItem(client, item, OnSpawned)
        else
            for key, value in pairs(product.Items) do
                if type(value) == "string" then
                    value = {Identifier = value}
                end

                ps.SpawnItem(client, value, OnSpawned)
            end
        end
    end

    if (product.Items == nil or #product.Items == 0) and product.Action then
        product.Action(client, product)
    end
end

ps.GetProductPrice = function (client, product)
    return product.Price + (product.Limit - ps.GetProductLimit(client, product)) * (product.PricePerLimit or 0)
end

ps.BuyProduct = function(client, product)
    if not Traitormod.Config.TestMode then
        local points = Traitormod.GetData(client, "Points") or 0
        local price = ps.GetProductPrice(client, product)

        if product.CanBuy then
            local success, result = product.CanBuy(client, product)
            if not success then
                return result or "This product cannot be used at the moment."
            end
        end

        if price > points then
            return ps.ProductBuyFailureReason.NoPoints
        end

        if product.Timeout ~= nil then
            if ps.Timeouts[client.SteamID] ~= nil and Timer.GetTime() < ps.Timeouts[client.SteamID] then
                local time = math.ceil(ps.Timeouts[client.SteamID] - Timer.GetTime())
                return "You have to wait " .. time .. " seconds before you can use this product."
            end

            ps.Timeouts[client.SteamID] = Timer.GetTime() + product.Timeout
        end

        if not ps.UseProductLimit(client, product) then
            return ps.ProductBuyFailureReason.NoStock
        end

        Traitormod.Log(string.format("PointShop: %s bought \"%s\".", Traitormod.ClientLogName(client), product.Name))
        Traitormod.SetData(client, "Points", points - price)

        Traitormod.Stats.AddClientStat("CrewBoughtItem", client, 1)
        Traitormod.Stats.AddListStat("ItemsBought", product.Name, 1)
    end

    -- Activate the product
    ps.ActivateProduct(client, product)
end

ps.HandleProductBuy = function (client, product, result)
    if result == ps.ProductBuyFailureReason.NoPoints then
        textPromptUtils.Prompt("You do not have enough points to buy this item.", {}, client, function (id, client) end, "gambler")
    elseif result == ps.ProductBuyFailureReason.NoStock then
        textPromptUtils.Prompt("This product is out of stock.", {}, client, function (id, client) end, "gambler")
    elseif result == nil then
        textPromptUtils.Prompt(string.format("Purchased \"%s\" for %s points\n\nNew point balance is: %s points.", product.Name, ps.GetProductPrice(client, product), math.floor(Traitormod.GetData(client, "Points") or 0)), {}, client, function (id, client) end, "gambler")
    else
        textPromptUtils.Prompt(result, {}, client, function (id, client) end, "gambler")
    end
end

ps.ShowCategoryItems = function(client, category)
    local options = {}
    local productsLookup = {}

    table.insert(options, ">> Go Back <<")
    table.insert(options, ">> Cancel <<")

    for key, product in pairs(category.Products) do
        if product.Enabled ~= false then
            local text = string.format("%s - %spt (%s/%s)",
                product.Name, ps.GetProductPrice(client, product), ps.GetProductLimit(client, product), product.Limit or defaultLimit)

            table.insert(options, text)
            productsLookup[#options] = product
        end
    end

    local emptyLines = math.floor(#options / 4)
    for i = 1, emptyLines, 1 do
        table.insert(options, "") -- FIXME: some hud scaling settings will hide list items
    end

    local points = Traitormod.GetData(client, "Points") or 0

    textPromptUtils.Prompt(
        "Your current balance: " .. math.floor(points) .." points\nWhat do you wish to buy?", 
        options, client, function (id, client2)
        if id == 1 then
            ps.ShowCategory(client2)
        end

        local product = productsLookup[id]
        if product == nil then return end

        local productHasInstallation = false

        if product.Items ~= nil then
            for key, value in pairs(product.Items) do
                if type(value) == "table" and value.IsInstallation then
                    productHasInstallation = true
                end
            end
        end

        if productHasInstallation then
            textPromptUtils.Prompt(
            "The product that you are about to buy will spawn an installation in your exact location, you won't be able to move it else where, do you wish to continue?\n",
            {"Yes", "No"}, client2, function (id, client3)
                if id == 1 then
                    if not ps.ValidateClient(client3) or not ps.CanClientAccessCategory(client2, category) then
                        return
                    end

                    local result = ps.BuyProduct(client3, product)
                    ps.HandleProductBuy(client3, product, result)
                end
            end, category.Decoration or "gambler", category.FadeToBlack)
        else
            if not ps.ValidateClient(client2) or not ps.CanClientAccessCategory(client2, category) then
                return
            end

            local result = ps.BuyProduct(client2, product)
            ps.HandleProductBuy(client2, product, result)
        end
    end, category.Decoration or "gambler", category.FadeToBlack)
end

ps.ShowCategory = function(client)
    local options = {}
    local categoryLookup = {}

    table.insert(options, ">> Cancel <<")

    for key, value in pairs(config.PointShopConfig.ItemCategories) do
        if ps.CanClientAccessCategory(client, value) then
            table.insert(options, value.Name)
            categoryLookup[#options] = value
        end
    end

    if #options == 1 then
        textPromptUtils.Prompt("Point Shop not available.", {}, client, function (id, client) end, "gambler")
        return
    end

    table.insert(options, "") -- FIXME: for some reason when the bar is full, the last item is never shown?

    local points = Traitormod.GetData(client, "Points") or 0

    -- note: we have two different client variables here to prevent cheating
    textPromptUtils.Prompt("Your current balance: " .. math.floor(points) .." points\nChoose a category.", options, client, function (id, client2)
        if categoryLookup[id] == nil then return end

        ps.ShowCategoryItems(client2, categoryLookup[id])
    end, "officeinside")
end

Traitormod.AddCommand({"!pointshop", "!pointsshop", "!ps", "!shop"}, function (client, args)
    if not ps.ValidateClient(client) then
        return true
    end

    if #args > 0 then
        local product = ps.FindProductByName(client, args[1])

        if product ~= nil then
            local amount = 1

            if args[2] ~= nil then
                amount = tonumber(args[2]) or amount
            end

            amount = math.min(amount, 8)

            for i=1, amount, 1 do
                local result = ps.BuyProduct(client, product)

                if result == ps.ProductBuyFailureReason.NoPoints then
                    Traitormod.SendMessage(client, "You do not have enough points to buy this item.")
                end

                if result == ps.ProductBuyFailureReason.NoStock then
                    Traitormod.SendMessage(client, "This product is out of stock.")
                end
            end

            return true
        end
    end

    ps.ShowCategory(client)

    return true
end)

Hook.Add("roundEnd", "TraitorMod.PointShop.RoundEnd", function ()
    ps.ResetProductLimits()
end)

Hook.Add("characterDeath", "Traitormod.Pointshop.Death", function (character)
    if character.IsPet then return end
    local client = Traitormod.FindClientCharacter(character)
    if client == nil then return end

    ps.Timeouts[client.SteamID] = Timer.GetTime() + config.PointShopConfig.DeathTimeoutTime
end)

ps.ValidateConfig()

for i, category in pairs(config.PointShopConfig.ItemCategories) do
    if category.Init then category.Init() end
end

return pslocal objective = Traitormod.RoleManager.Objectives.Objective:new()

objective.Name = "PoisonCaptain"
objective.RoleFilter = { ["captain"] = true }
objective.AmountPoints = 1600

function objective:Start(target)
    self.Target = target

    if self.Target == nil then
        return false
    end

    if not self.Character.JobIdentifier == "prisondoctor" then
        Traitormod.Debug("PoisonCaptain is only available for medics.")
        return false
    end

    self.TargetName = Traitormod.GetJobString(self.Target)

    self.Poison = "Sufforin"

    self.Text = string.format(Traitormod.Language.ObjectivePoisonCaptain, self.TargetName,
        self.Poison)

    return true
end

function objective:IsCompleted()
    if self.Target == nil then
        return
    end

    local aff = self.Target.CharacterHealth.GetAffliction("sufforinpoisoning", true)

    if aff ~= nil and aff.Strength > 10 then
        return true
    end

    return false
end

return objective
local category = {}

category.Name = "Convict Uplink"
category.Decoration = "Separatists"
category.FadeToBlack = true

category.CanAccess = function(client)
    return client.Character and not client.Character.IsDead and client.Character.HasJob("convict")
end

category.Products = {

    {
        Name = "Beanie",
        Price = 1,
        Limit = 1,
        IsLimitGlobal = false,
        Items = {"touque"},
    },

    {
        Name = "Lockpick",
        Price = 300,
        Limit = 1,
        IsLimitGlobal = false,
        Items = {"ah_lockpick"},
    },

    {
        Name = "Crowbar",
        Price = 600,
        Limit = 1,
        IsLimitGlobal = true,
        Items = {"crowbar"},
    },

    {
        Name = "Wrench",
        Price = 50,
        Limit = 2,
        IsLimitGlobal = true,
        Items = {"wrench"},
    },

    {
        Name = "Shiv",
        Price = 400,
        Limit = 2,
        IsLimitGlobal = true,
        Items = {"divingknife"},
    },

    {
        Name = "Premium Shiv",
        Price = 1100,
        Limit = 1,
        IsLimitGlobal = true,
        Items = {"frogsstabbingknife"},
    },

    {
        Name = "Ol' Choppy",
        Price = 2000,
        Limit = 1,
        IsLimitGlobal = true,
        Items = {"frogspyschoknife"},
    },

    {
        Name = "Meth",
        Price = 100,
        Limit = 1,
        IsLimitGlobal = false,
        Items = {"meth", "meth"},
    },

    {
        Name = "Steroids",
        Price = 100,
        Limit = 1,
        IsLimitGlobal = false,
        Items = {"steroids", "steroids"},
    },

    {
        Name = "Separatist Gear",
        Price = 3250,
        Limit = 1,
        IsLimitGlobal = true,
        Items = {"pirateclotheshard", "piratebodyarmor", "piratebandana"},
    },

    {
        Name = "Suicide Vest",
        Price = 5000,
        Limit = 1,
        IsLimitGlobal = true,
        Items = {"suicidevestDJL", "uex"},
    },

    {
        Name = "Molotov",
        Price = 3500,
        Limit = 2,
        IsLimitGlobal = true,
        Items = {"molotovcoctail"},
    },

    {
        Name = "Stun Grenade",
        Price = 715,
        Limit = 2,
        IsLimitGlobal = true,
        Items = {"stungrenade"},
    },

    {
        Name = "Mutated Pomegrenade",
        Price = 1250,
        Limit = 2,
        IsLimitGlobal = true,
        Items = {"badcreepingorange"},
    },

    {
        Name = "Boom Stick",
        Price = 10000,
        Limit = 1,
        IsLimitGlobal = true,
        Items = {"shotgununique", 
        "shotgunshell", "shotgunshell", "shotgunshell","shotgunshell", "shotgunshell", "shotgunshell", "shotgunshell"},
    },

    {
        Name = "Turn Off Lights For 3 Minutes",
        Price = 950,
        Limit = 1,
        IsLimitGlobal = true,

        CanBuy = function (client, product)
            return not Traitormod.RoundEvents.IsEventActive("LightsOff")
        end,

        Action = function ()
            Traitormod.RoundEvents.TriggerEvent("LightsOff")
        end
    },

    {
        Name = "Turn Off Communications For 2 Minutes",
        Price = 1000,
        Limit = 1,
        IsLimitGlobal = true,

        CanBuy = function (client, product)
            return not Traitormod.RoundEvents.IsEventActive("CommunicationsOffline")
        end,

        Action = function ()
            Traitormod.RoundEvents.TriggerEvent("CommunicationsOffline")
        end
    },

    {
        Name = "Sabotage Oxygen Generator [Warn Other Prisoners]",
        Price = 9500,
        Limit = 1,
        IsLimitGlobal = true,

        CanBuy = function (client, product)
            return not Traitormod.RoundEvents.IsEventActive("OxygenGeneratorPoison")
        end,

        Action = function ()
            Traitormod.RoundEvents.TriggerEvent("OxygenGeneratorPoison")
        end
    },
}

return categorylocal weightedRandom = dofile(Traitormod.Path .. "/Lua/weightedrandom.lua")
local gm = Traitormod.Gamemodes.Gamemode:new()

gm.Name = "PvP"

function gm:Start()
    if self.EnableRandomEvents then
        Traitormod.RoundEvents.Initialize()
    end

    if self.ShowSonar then
        for key, submarine in pairs(Submarine.MainSubs) do
            Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.Prefabs["sonarbeacon"], submarine.WorldPosition, nil, nil, function(item)
                item.NonInteractable = true

                Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.Prefabs["batterycell"], item.OwnInventory, nil, nil, function(bat)
                    bat.Indestructible = true

                    local interface = item.GetComponentString("CustomInterface")

                    interface.customInterfaceElementList[1].State = true

                    if key == 1 then
                        interface.customInterfaceElementList[2].Signal = "Left Submarine"
                    else
                        interface.customInterfaceElementList[2].Signal = "Right Submarine"
                    end

                    item.CreateServerEvent(interface, interface)
                end)
            end) 
        end
    end

    self.CharacterToClient = {}

    for key, value in pairs(Client.ClientList) do
        local character = value.Character
        if value.Character then
            self.CharacterToClient[character] = value
        end
    end

    for key, value in pairs(Character.CharacterList) do
        if value.IsHuman then
            if self.IdCardAllAccess then
                local idCard = value.Inventory.GetItemInLimbSlot(InvSlotType.Card)

                if idCard then
                    idCard.AddTag("id_captain")
                end
            end

            if self.CrossTeamCommunication then
                local radio = value.Inventory.GetItemInLimbSlot(InvSlotType.Headset)
                if radio then
                    local wifi = radio.GetComponentString("WifiComponent")
                    wifi.AllowCrossTeamCommunication = true
                end
            end
        end
    end
end

function gm:AwardPoints()
    for key, value in pairs(Character.CharacterList) do
        local client = self.CharacterToClient[value]
        if client == nil then
            for key, value2 in pairs(Client.ClientList) do
                if value2.Character == value then
                    client = value2
                end
            end
        end

        if client and client.Character and client.Character.TeamID == Game.GameSession.WinningTeam then
            local amount = self.WinningPoints
            if client.Character.IsDead then
                amount = self.WinningDeadPoints
            end

            local points = Traitormod.AwardPoints(client, amount)
            Traitormod.SendMessage(client, "You have received " .. points .. " points.", "InfoFrameTabButton.Mission")
        end
    end
end

function gm:End()
    if #Client.ClientList >= self.MinimumPlayersForPoints then
        self:AwardPoints()
    end

    Hook.Remove("item.created", "Traitormod.PvP.IdCard")

    -- first arg = mission id, second = message, third = completed, forth = list of characters
    return nil
end

function gm:Think()

end

return gm
local objective = Traitormod.RoleManager.Objectives.Objective:new()

objective.Name = "Repair"
objective.AmountPoints = 400
objective.Amount = 5
objective.ItemIdentifier = "junctionbox"
objective.ItemText = "Junction Boxes"
objective.MinCondition = 20

function objective:Start(target)
    self.Progress = 0

    self.Text = string.format("Repair (%s/%s) %s that had their condition below %s", self.Progress, self.Amount, self.ItemText, self.MinCondition)

    return true
end

function objective:StopRepairing(item, character)
    if item.Prefab.Identifier == self.ItemIdentifier and character == self.Character then
        self.Progress = self.Progress + 1
        self.Text = string.format("Repair (%s/%s) %s that had their condition below %s%%", self.Progress, self.Amount, self.ItemText, self.MinCondition)
    end
end

function objective:IsCompleted()
    if self.Progress >= self.Amount then
        return true
    end

    return false
end

return objective
if Traitormod.SubmarineBuilder == nil then
    return
end

Game.OverrideRespawnSub(true) -- remove respawn submarine logic

Traitormod.RespawnedCharacters = {}

local sb = Traitormod.SubmarineBuilder
local submarineId = sb.AddSubmarine(Traitormod.Config.RespawnSubmarineFile)

local timerActive = false
local transporting = false
local respawnTimer = 0
local transportTimer = 0

local lastTimerDisplay = 0

local function RespawnMessage(msg)
    for key, client in pairs(Client.ClientList) do
        local chatMessage = ChatMessage.Create("", msg, ChatMessageType.Default, nil, nil)
        chatMessage.Color = Color(178, 35, 199, 255)
        Game.SendDirectChatMessage(chatMessage, client)
    end

    Traitormod.Log(msg)
end

local function GetRespawnClients()
    local clients = {}
    for key, value in pairs(Client.ClientList) do
        if value.Character == nil or value.Character.IsDead then
            table.insert(clients, value)
        end
    end

    return clients
end

local function IsCloseToOtherSubmarines(position)
    for key, value in pairs(Submarine.Loaded) do
        if Vector2.Distance(value.WorldPosition, position) < 10000 then
            return true
        end
    end

    return false
end

local function FindSpawnPosition()
    local potentialSpawnPositions = {}

    for _, spawnPosition in pairs(Level.Loaded.PositionsOfInterest) do
        if spawnPosition.PositionType == Level.PositionType.MainPath then
            local position = spawnPosition.Position.ToVector2()
            if not IsCloseToOtherSubmarines(position) then
                table.insert(potentialSpawnPositions, position)
            end
        end
    end

    local bestPosition = potentialSpawnPositions[1]

    if bestPosition == nil then
        Traitormod.Error("Couldn't find a good spawn position for the respawn shuttle!")
        return Vector2(Level.Loaded.Size.X / 2, Level.Loaded.Size.Y / 2)
    end

    for key, value in pairs(potentialSpawnPositions) do
        if Vector2.Distance(Submarine.MainSub.WorldPosition, value) < Vector2.Distance(Submarine.MainSub.WorldPosition, bestPosition) then
            bestPosition = value
        end
    end

    return bestPosition
end

local function SpawnCharacter(client, submarine)
    if client.SpectateOnly or client.CharacterInfo == nil then return false end

    local spawnWayPoints = WayPoint.SelectCrewSpawnPoints({client.CharacterInfo}, submarine)

    local potentialPosition = submarine.WorldPosition

    if spawnWayPoints[1] == nil then
        for i, waypoint in pairs(WayPoint.WayPointList) do
            if waypoint.Submarine == submarine and waypoint.CurrentHull ~= nil then
                potentialPosition = waypoint.WorldPosition
                break
            end
        end
    else
        potentialPosition = spawnWayPoints[1].WorldPosition
    end

    local character = Character.Create(client.CharacterInfo, potentialPosition, client.CharacterInfo.Name, 0, true, true)

    character.TeamID = Traitormod.Config.RespawnTeam

    client.SetClientCharacter(character)

    character.GiveJobItems()
    character.LoadTalents()

    Traitormod.RespawnedCharacters[character] = client

    if Traitormod.Config.RespawnedPlayersDontLooseLives then
        Traitormod.LostLivesThisRound[client.SteamID] = true
    end
end

local function ResetSubmarine(submarine)
    for key, item in pairs(submarine.GetItems(true)) do
        item.Condition = item.MaxCondition

        local repairable = item.GetComponentString("Repairable")
        if repairable then repairable.ResetDeterioration() end

        local powerContainer = item.GetComponentString("PowerContainer")
        if powerContainer then powerContainer.Charge = powerContainer.Capacity end
    end

    for key, hull in pairs(Hull.HullList) do
        if hull.Submarine == submarine then
            hull.OxygenPercentage = 100
            hull.WaterVolume = 0
            if hull.BallastFlora then
                hull.BallastFlora.Remove()
            end
        end
    end

    for key, wall in pairs(Structure.WallList) do
        if wall.Submarine == submarine then
            for i = 0, wall.SectionCount, 1 do
                wall.AddDamage(i, -1000000)
            end
        end
    end

    for key, character in pairs(Character.CharacterList) do
        if character.Submarine == submarine then
            Entity.Spawner.AddEntityToRemoveQueue(character)            
        end
    end
end

Hook.Add("think", "RespawnShuttle.Think", function ()
    if not Game.RoundStarted then return end
    if not Traitormod.SubmarineBuilder.IsActive() then return end

    local ratio = #GetRespawnClients() / #Client.ClientList

    if #Client.ClientList == 0 then
        ratio = 0
    end

    if ratio > Game.ServerSettings.MinRespawnRatio then
        if not timerActive and not transporting then
            timerActive = true
            respawnTimer = Game.ServerSettings.RespawnInterval
            lastTimerDisplay = respawnTimer
            RespawnMessage(string.format(Traitormod.Config.RespawnText, math.floor(respawnTimer)))
        end
    else
        timerActive = false
    end

    if timerActive then
        respawnTimer = respawnTimer - (1 / 60)
    end

    if transporting then
        transportTimer = transportTimer - (1 / 60)
    end

    local timerDisplayMax = 15

    if respawnTimer < 10 then
        timerDisplayMax = 1
    end

    if timerActive and (lastTimerDisplay - respawnTimer) > timerDisplayMax then
        lastTimerDisplay = respawnTimer
        RespawnMessage(string.format(Traitormod.Config.RespawnText, math.floor(respawnTimer)))
    end

    if transportTimer <= 0 and not timerActive and transporting then
        transporting = false
        timerActive = false
    end

    if respawnTimer <= 0 and timerActive and not transporting then
        transporting = true
        timerActive = false

        local submarine = sb.FindSubmarine(submarineId)
        submarine.GodMode = false
        submarine.TeamID = Traitormod.Config.RespawnTeam

        ResetSubmarine(submarine)
        local position = FindSpawnPosition()
        submarine.SetPosition(position)

        sb.ResetSubmarineSteering(submarine)

        local clients = GetRespawnClients()

        for key, client in pairs(clients) do
            SpawnCharacter(client, submarine)
        end

        transportTimer = Game.ServerSettings.MaxTransportTime
    end
end)

Hook.Add("roundEnd", "RespawnShuttle.RoundEnd", function ()
    timerActive = false
    transporting = false
    respawnTimer = 0
    transportTimer = 0
    lastTimerDisplay = 0
    Traitormod.RespawnedCharacters = {}
end)

Hook.Add("character.death", "RespawnShuttle.CharacterDeath", function (character)
    if Traitormod.Config.RespawnOnKillPoints == 0 then return end
    if not Traitormod.RespawnedCharacters[character] then return end

    if not character.CauseOfDeath then return end
    if not character.CauseOfDeath.Killer then return end

    local killer = character.CauseOfDeath.Killer
    local killerClient = Traitormod.FindClientCharacter(character.CauseOfDeath.Killer)

    if not killerClient then return end

    if killer.IsHuman and killer.TeamID == CharacterTeamType.FriendlyNPC and not killer.IsDead and not Traitormod.RespawnedCharacters[killer] then
        Traitormod.AwardPoints(killerClient, Traitormod.Config.RespawnOnKillPoints)
        Traitormod.SendMessage(killerClient, "You have received " .. Traitormod.Config.RespawnOnKillPoints .. " points.", "InfoFrameTabButton.Mission")
    end
end)local role = {}

role.Name = "Role"
role.IsAntagonist = false

function role:Init(character)
    self.Character = character
    self.Objectives = {}
    self.RoundNumber = Traitormod.RoundNumber
end

function role:Transfer(character)
    self.Character = character

    for key, value in pairs(self.Objectives) do
        value.Character = character
    end
end

function role:Start()

end

function role:End(roundEnd)

end

function role:NewMember(character)

end

function role:Greet()
   return ""
end

function role:OtherGreet()
    return ""
end

function role:AssignObjective(objective)
    table.insert(self.Objectives, objective)
end

function role:CompletedObjectives(name)
    local num = 0
    for key, value in pairs(self.Objectives) do
        if value.Name == name then
            num = num + 1
        end
    end
    return num
end

function role:FindValidTarget(objective)
    local targets = {}
    local debug = ""
    for key, value in pairs(Character.CharacterList) do
        if self:FilterTarget(objective, value) then
            table.insert(targets, value)
            debug = debug .. " | " .. value.Name .. " (" .. tostring(value.Info.Job.Prefab.Identifier) .. value.TeamID .. ")"
        end
    end

    Traitormod.Debug("Selecting new random target out of " .. #targets .. " possible candidates" .. debug)
    if #targets > 0 then
        local chosenTarget = targets[math.random(1, #targets)]
        return chosenTarget
    end

    return nil
end

function role:FilterTarget(objective, character)
    if character == botGod then return false end
    if not character.IsHuman or character.IsDead then return false end
    if objective.RoleFilter ~= nil and not objective.RoleFilter[character.Info.Job.Prefab.Identifier.Value] then
        return false
    end

    if Traitormod.RoleManager.IsSameRole(self, character) then return false end

    return true
end

function role:new(o)
    o = o or {}
    setmetatable(o, self)
    self.__index = self
    return o
end

return role
local rm = {}

rm.Roles = {}
rm.Objectives = {}

rm.RoundRoles = {}

rm.FindObjective = function(name)
    return rm.Objectives[name]
end

rm.RandomObjective = function(allowedObjectives)
    if allowedObjectives == nil then
        for key, value in pairs(rm.Objectives) do
            table.insert(allowedObjectives, key)
        end
    end

    local objectives = {}

    for _, objective in pairs(rm.Objectives) do
        for _, allowedName in pairs(allowedObjectives) do
            if objective.Name == allowedName then
                table.insert(objectives, objective)
            end
        end
    end

    return objectives[Random.Range(1, #objectives + 1)]
end

rm.AddObjective = function(objective)
    rm.Objectives[objective.Name] = objective

    if Traitormod.Config.ObjectiveConfig[objective.Name] ~= nil then
        for key, value in pairs(Traitormod.Config.ObjectiveConfig[objective.Name]) do
            objective[key] = value
        end
    end
end

rm.CheckObjectives = function(endRound)
    for character, role in pairs(rm.RoundRoles) do
        if not character.IsDead and role.Objectives then
            for _, objective in pairs(role.Objectives) do
                if objective.EndRoundObjective == endRound and not objective.Awarded then
                    if objective:IsCompleted() then
                        objective:Award()
                    elseif objective:IsFailed() then
                        objective:Fail()
                    end
                end
            end
        end
    end
end

rm.FindRole = function(name)
    return rm.Roles[name]
end

rm.AddRole = function(role)
    rm.Roles[role.Name] = role

    if Traitormod.Config.RoleConfig[role.Name] ~= nil then
        for key, value in pairs(Traitormod.Config.RoleConfig[role.Name]) do
            role[key] = value
        end
    end
end

rm.AssignRole = function(character, newRole)
    if rm.RoundRoles[character] ~= nil then
        error("character" .. character.Name .. " already has a role.", 2)
    end

    Traitormod.Log("Assigned role " .. newRole.Name .. " to " .. character.Name .. ".")

    for key, role in pairs(rm.RoundRoles) do
        if role.Name == newRole.Name then
            role:NewMember(key)
        end
    end

    rm.RoundRoles[character] = newRole

    newRole:Init(character)
    newRole:Start()
end

rm.TransferRole = function(character, oldRole)
    rm.RoundRoles[oldRole.Character] = nil
    rm.RoundRoles[character] = oldRole

    oldRole:Transfer(character)
end

rm.RemoveRole = function (character)
    local role = rm.GetRole(character)
    if role == nil then return end

    role:End()
    rm.RoundRoles[character] = nil

    Traitormod.Log("Removed role " .. role.Name .. " from " .. character.Name .. ".")
end

rm.AssignRoles = function(characters, newRoles)
    for key, value in pairs(characters) do
        if rm.RoundRoles[value] ~= nil then
            error("character" .. value.Name .. " already has a role.", 2)
        end
    end

    for i = 1, #characters, 1 do
        for character, role in pairs(rm.RoundRoles) do
            if newRoles[i].Name == role.Name then
                role:NewMember(character)
            end
        end
    end

    for i = 1, #characters, 1 do
        rm.RoundRoles[characters[i]] = newRoles[i]
        newRoles[i]:Init(characters[i])
    end

    for i = 1, #characters, 1 do
        newRoles[i]:Start()
    end
end

rm.HasRole = function (character, name)
    local role = rm.GetRole(character)
    if role == nil then return false end
    return role.Name == name
end

rm.FindCharactersByRole = function(name)
    local characters = {}

    for character, role in pairs(rm.RoundRoles) do
        if role.Name == name then
            table.insert(characters, character)
        end
    end

    return characters
end

rm.FindAntagonists = function()
    local characters = {}

    for character, role in pairs(rm.RoundRoles) do
        if role.IsAntagonist then
            table.insert(characters, character)
        end
    end

    return characters
end

rm.GetRole = function(character)
    if character == nil then return nil end

    return rm.RoundRoles[character]
end

rm.IsAntagonist = function (character)
    local role = rm.GetRole(character)
    if role == nil then return false end
    return role.IsAntagonist
end

rm.IsSameRole = function (character1, character2)
    local role1, role2

    if type(character1) == "table" then
        role1 = character1
    else
        role1 = rm.GetRole(character1)
    end

    if type(character2) == "table" then
        role2 = character2
    else
        role2 = rm.GetRole(character2)
    end

    if role1 == nil or role2 == nil then return false end

    return role1.Name == role2.Name
end

rm.CallObjectiveFunction = function (functionName, ...)
    for character, role in pairs(rm.RoundRoles) do
        if not character.IsDead and role.Objectives then
            for _, objective in pairs(role.Objectives) do
                objective[functionName](objective, ...)
            end
        end
    end
end

Hook.Add("think", "Traitormod.RoleManager.Think", function()
    if not Game.RoundStarted then return end
    rm.CheckObjectives(false)
end)

Hook.Add("characterDeath", "Traitormod.RoleManager.CharacterDeath", function(deadCharacter)
    rm.CallObjectiveFunction("CharacterDeath", deadCharacter)

    local role = rm.GetRole(deadCharacter)
    if role then
        role:End()
    end
end)

Hook.Patch("Barotrauma.Items.Components.Repairable", "StopRepairing", function (instance, ptable)
    rm.CallObjectiveFunction("StopRepairing", instance.Item, ptable["character"])
end)

rm.EndRound = function ()
    rm.CheckObjectives(true)

    for key, role in pairs(rm.RoundRoles) do
        role:End(true)
    end

    rm.RoundRoles = {}
end

return rm
local re = {}

LuaUserData.RegisterType("Barotrauma.EventManager") -- temporary

re.OnGoingEvents = {}

re.ThisRoundEvents = {}
re.EventConfigs = Traitormod.Config.RandomEventConfig

re.AllowedEvents = {}

re.IsEventActive = function (eventName)
    if re.OnGoingEvents[eventName] then
        return true
    end
    return false
end

re.EventExists = function (eventName)
    local event = nil
    for _, value in pairs(re.EventConfigs.Events) do
        if value.Name == eventName then
            event = value
        end
    end

    return event ~= nil
end

re.TriggerEvent = function (eventName)
    if not Game.RoundStarted then
        Traitormod.Error("Tried to trigger event " .. eventName .. ", but round is not started.")
        return
    end

    if re.OnGoingEvents[eventName] then
        Traitormod.Error("Event " .. eventName .. " is already running.")
        return
    end

    local event = nil
    for _, value in pairs(re.EventConfigs.Events) do
        if value.Name == eventName then
            event = value
        end
    end

    if event == nil then
        Traitormod.Error("Tried to trigger event " .. eventName .. " but it doesnt exist or is disabled.")
        return
    end

    local originalEnd = event.End
    event.End = function (isRoundEnd)
        re.OnGoingEvents[eventName] = nil
        originalEnd(isRoundEnd)
    end

    Traitormod.Stats.AddStat("EventTriggered", event.Name, 1)

    re.OnGoingEvents[eventName] = event
    event.Start()

    if re.ThisRoundEvents[eventName] == nil then
        re.ThisRoundEvents[eventName] = 0
    end
    re.ThisRoundEvents[eventName] = re.ThisRoundEvents[eventName] + 1

    Traitormod.Log("Event " .. eventName .. " triggered.")
end

re.CheckRandomEvent = function (event)
    if event.MinRoundTime ~= nil and Traitormod.RoundTime / 60 < event.MinRoundTime then
        return
    end

    if event.MaxRoundTime ~= nil and Traitormod.RoundTime / 60 > event.MaxRoundTime then
        return
    end

    local intensity = Game.GameSession.EventManager.CurrentIntensity

    if event.MinIntensity ~= nil and intensity < event.MinIntensity then
        return
    end

    if event.MaxIntensity ~= nil and intensity > event.MaxIntensity then
        return
    end

    if math.random() > event.ChancePerMinute then
        return
    end

    Traitormod.Log("Selected random event to trigger \"" .. event.Name .. "\" with intensity " .. intensity .. " and round time " .. Traitormod.RoundTime / 60 .. " minutes.")

    re.TriggerEvent(event.Name)
end

re.SendEventMessage = function (text, icon, color)
    for key, value in pairs(Client.ClientList) do
        local messageChat = ChatMessage.Create("", text, ChatMessageType.Default, nil, nil)
        messageChat.Color = Color(200, 30, 241, 255)
        Game.SendDirectChatMessage(messageChat, value)

        local messageBox = ChatMessage.Create("", text, ChatMessageType.ServerMessageBoxInGame, nil, nil)
        messageBox.IconStyle = icon
        if color then messageBox.Color = color end
        Game.SendDirectChatMessage(messageBox, value)
    end 
end

local lastRandomEventCheck = 0
Hook.Add("think", "TraitorMod.RoundEvents.Think", function ()
    if not Game.RoundStarted then return end

    if Timer.GetTime() > lastRandomEventCheck then
        for _, event in pairs(re.EventConfigs.Events) do
            if re.OnGoingEvents[event.Name] == nil and re.AllowedEvents[event.Name] then
                if not event.OnlyOncePerRound or re.ThisRoundEvents[event.Name] == nil then
                    re.CheckRandomEvent(event)
                end
            end
        end
        lastRandomEventCheck = Timer.GetTime() + 60
    end
end)

re.Initialize = function (allowedEvents)
    re.AllowedEvents = {}

    if allowedEvents == nil then
        for key, value in pairs(re.EventConfigs.Events) do
            re.AllowedEvents[value.Name] = true
        end
    else
        for key, value in pairs(allowedEvents) do
            re.AllowedEvents[value] = true
        end
    end
end

re.EndRound = function ()
    for key, value in pairs(re.OnGoingEvents) do
        value.End(true)
        re.OnGoingEvents[key] = nil
    end

    re.ThisRoundEvents = {}
    re.AllowedEvents = {}
end

for _, value in pairs(re.EventConfigs.Events) do
    if value.Init then value.Init() end
end

return relocal objective = Traitormod.RoleManager.Objectives.Objective:new()

objective.Name = "SavePrisoner"
objective.RoleFilter = { ["convict"] = true }
objective.AmountPoints = 2100

function objective:Start(target)
    self.Target = target

    if self.Target == nil then
        return false
    end

    self.TargetName = Traitormod.GetJobString(self.Target)

    self.Text = "Save convict "..self.Target.Name.." from this filthy prison."

    return true
end

function objective:IsCompleted()
    if self.Target == nil then
        return false 
    end

    if self.Target.Submarine ~= Submarine.MainSub then
        return true
    end

    return false
end

function objective:IsFailed()
    if self.Target == nil then
        return false
    end

    if self.Target.IsDead then
        return true
    end

    return false
end

return objective
local weightedRandom = dofile(Traitormod.Path .. "/Lua/weightedrandom.lua")
local gm = Traitormod.Gamemodes.Gamemode:new()

gm.Name = "Secret"

function gm:CharacterDeath(character)
    local client = Traitormod.FindClientCharacter(character)

    -- if character is valid player
    if client == nil or
        character == nil or
        character.IsHuman == false or
        character.ClientDisconnected == true or
        character.TeamID == 0 then
        return
    end

    if Traitormod.RoundTime < Traitormod.Config.MinRoundTimeToLooseLives then
        return
    end

    if Traitormod.LostLivesThisRound[client.SteamID] == nil then
        Traitormod.LostLivesThisRound[client.SteamID] = true
    else
        return
    end

    local liveMsg, liveIcon = Traitormod.AdjustLives(client, -1)

    Traitormod.SendMessage(client, liveMsg, liveIcon)
end

function gm:Start()
    local this = self

    if self.EnableRandomEvents then
        Traitormod.RoundEvents.Initialize()
    end

    Hook.Add("characterDeath", "Traitormod.Secret.CharacterDeath", function(character, affliction)
        this:CharacterDeath(character)
    end)

    self.TraitorType = Traitormod.RoleManager.Roles[weightedRandom.Choose(self.TraitorTypeChance)]

    if self.TraitorType.Name == "Cultist" then
        self.RoundEndIcon = "oneofus"
        Game.EnableControlHusk(true)
    else
        Game.EnableControlHusk(false)
    end

    self:SelectAntagonists(self.TraitorType)
end

function gm:AwardCrew()
    local missionType = {}

    for key, value in pairs(MissionType) do
        missionType[value] = key
    end

    local missionReward = 0
    for _, mission in pairs(Traitormod.RoundMissions) do
        if mission.Completed then
            local type = missionType[mission.Prefab.Type]
            local missionValue = self.MissionPoints.Default

            for key, value in pairs(self.MissionPoints) do
                if key == type then
                    missionValue = value
                end
            end

            missionReward = missionReward + missionValue
        end
    end

    for key, value in pairs(Client.ClientList) do
        if value.Character ~= nil
            and value.Character.IsHuman
            and not value.SpectateOnly
            and not value.Character.IsDead
        then
            local role = Traitormod.RoleManager.GetRole(value.Character)

            local wasAntagonist = false
            if role ~= nil then
                wasAntagonist = role.IsAntagonist
            end

            -- if client was no traitor, and in reach of end position, gain a live
            if not wasAntagonist and Traitormod.EndReached(value.Character, self.DistanceToEndOutpostRequired) then
                local msg = ""

                -- award points for mission completion
                if missionReward > 0 then
                    local points = Traitormod.AwardPoints(value, missionReward
                        , true)
                    msg = msg ..
                        Traitormod.Language.CrewWins ..
                        " " .. string.format(Traitormod.Language.PointsAwarded, points) .. "\n\n"
                end

                local lifeMsg, icon = Traitormod.AdjustLives(value,
                    (self.LivesGainedFromCrewMissionsCompleted or 1))
                if lifeMsg then
                    msg = msg .. lifeMsg .. "\n\n"
                end

                if msg ~= "" then
                    Traitormod.SendMessage(value, msg, icon)
                end
            end
        end
    end
end

function gm:CheckHandcuffedTraitors(character)
    if character.IsDead then return end
    
    local item = character.Inventory.GetItemInLimbSlot(InvSlotType.RightHand)
    if item ~= nil and item.Prefab.Identifier == "handcuffs" then
        for key, value in pairs(Client.ClientList) do
            local role = Traitormod.RoleManager.GetRole(value.Character)
            if (role == nil or not role.IsAntagonist) and value.Character and not value.Character.IsDead and value.Character.TeamID == CharacterTeamType.FriendlyNPC then
                local points = Traitormod.AwardPoints(value, self.PointsGainedFromHandcuffedTraitors)
                local text = string.format(Traitormod.Language.TraitorHandcuffed, character.Name)
                text = text .. "\n\n" .. string.format(Traitormod.Language.PointsAwarded, points)
                Traitormod.SendMessage(value, text, "InfoFrameTabButton.Mission")
            end
        end
    end
end

function gm:TraitorResults()
    local success = false

    local sb = Traitormod.StringBuilder:new()

    local antagonists = {}
    for character, role in pairs(Traitormod.RoleManager.RoundRoles) do
        if role.IsAntagonist then
            table.insert(antagonists, character)
        end

        if role.IsAntagonist then
            sb("%s %s", role.Name, character.Name)
            sb("\n")

            local objectives = 0
            local pointsGained = 0

            for key, value in pairs(role.Objectives) do
                if value:IsCompleted() then
                    objectives = objectives + 1
                    pointsGained = pointsGained + value.AmountPoints
                end
            end

            if objectives > 0 then
                success = true
            end

            sb("Objectives Completed: %s - Points Gained: %s\n", objectives, pointsGained)
        end
    end

    if success then
        Traitormod.Stats.AddStat("Rounds", "Traitor rounds won", 1)
    else
        Traitormod.Stats.AddStat("Rounds", "Crew rounds won", 1)
    end

    -- first arg = mission id, second = message, third = completed, forth = list of characters
    return {TraitorMissionResult(self.RoundEndIcon or Traitormod.MissionIdentifier, sb:concat(), success, antagonists)}
end

function gm:End()
    for key, character in pairs(Traitormod.RoleManager.FindAntagonists()) do
        self:CheckHandcuffedTraitors(character)
    end

    gm:AwardCrew()

    Hook.Remove("characterDeath", "Traitormod.Secret.CharacterDeath");
end

function gm:SelectAntagonists(role)
    local this = self
    local thisRoundNumber = Traitormod.RoundNumber

    local delay = math.random(self.TraitorSelectDelayMin, self.TraitorSelectDelayMax)

    Timer.Wait(function()
        if thisRoundNumber ~= Traitormod.RoundNumber or not Game.RoundStarted then return end

        local clientWeight = {}
        local traitorChoices = 0
        local playerInGame = 0
        for key, value in pairs(Client.ClientList) do
            -- valid traitor choices must be ingame, player was spawned before (has a character), is no spectator
            if value.InGame and value.Character and not value.SpectateOnly then
                -- filter by config
                if this.TraitorFilter(value) > 0 and Traitormod.GetData(value, "NonTraitor") ~= true then
                    -- players are alive or if respawning is on and config allows dead traitors (not supported yet)
                    if not value.Character.IsDead then
                        clientWeight[value] = (Traitormod.GetData(value, "Weight") or 0) * this.TraitorFilter(value)
                        traitorChoices = traitorChoices + 1
                    end
                end
                playerInGame = playerInGame + 1
            end
        end

        if traitorChoices == 0 then
            if Game.ServerSettings.AllowRespawn or MidRoundSpawn then
                -- if more players to come, retry
                Traitormod.Debug("Currently no valid player characters to assign traitors. Retrying...")
                this:SelectAntagonists(role)
            else
                -- else this will never change, abort
                Traitormod.Log("No players to assign traitors")
            end

            return
        end

        local amountTraitors = this.AmountTraitors(playerInGame)
        if amountTraitors > traitorChoices then
            amountTraitors = traitorChoices
            Traitormod.Log("Not enough valid players to assign all traitors... New amount: " .. tostring(amountTraitors))
        end

        local antagonists = {}
        local roles = {}

        for i = 1, amountTraitors, 1 do
            local index = weightedRandom.Choose(clientWeight)

            if index ~= nil then
                Traitormod.Log("Chose " ..
                    index.Character.Name .. " as traitor. Weight: " .. math.floor(clientWeight[index] * 100) / 100)

                table.insert(antagonists, index.Character)
                table.insert(roles, role:new())

                clientWeight[index] = nil

                Traitormod.SetData(index, "Weight", 0)
            end
        end

        Traitormod.RoleManager.AssignRoles(antagonists, roles)

    end, delay * 1000)
end

function gm:Think()
    local ended = true
    local anyTraitorMission = false

    for key, value in pairs(Character.CharacterList) do
        if not value.IsDead and value.IsHuman and value.TeamID == CharacterTeamType.FriendlyNPC then
            local role = Traitormod.RoleManager.GetRole(value)
            if role == nil or not role.IsAntagonist then
                ended = false
            else
                if role.Objectives then
                    for key, objective in pairs(role.Objectives) do
                        if objective.Name == "Assassinate" or objective.Name == "Husk" then
                            anyTraitorMission = true
                        end
                    end
                end
            end
        end
    end

    if not anyTraitorMission then
        ended = false
    end

    if not self.Ending and Game.RoundStarted and self.EndOnComplete and ended then
        local delay = self.EndGameDelaySeconds or 0

        Traitormod.SendMessageEveryone(Traitormod.Language.TraitorsWin)
        Traitormod.Log("Secret gamemode complete. Ending round in " .. delay)

        Timer.Wait(function ()
            Game.EndGame()
        end, delay * 1000)

        self.Ending = true
    end
end

return gm
local objective = Traitormod.RoleManager.Objectives.Objective:new()

objective.Name = "Secure Convicts"
objective.AmountPoints = 0

function objective:Start(target)
    self.Text = "Secure convicts inside the submarine."

    return true
end

function objective:IsCompleted()
    local numConvicts = 0
    local numAliveConvictsInsideSub = 0

    for _, player in ipairs(Traitormod.GetAlivePlayers()) do
        if player.Character.HasJob("convict") then
            numConvicts = numConvicts + 1

            if player.Character.Submarine == Submarine.MainSub then
                numAliveConvictsInsideSub = numAliveConvictsInsideSub + 1
            end
        end
    end

    self.AmountPoints = numAliveConvictsInsideSub * 500

    return numConvicts >= self.Amount
end

return objective
local category = {}

category.Name = "Security"
category.Decoration = "security"

category.CanAccess = function(client)
    return client.Character and not client.Character.IsDead and 
    (client.Character.HasJob("headguard") or client.Character.HasJob("guard") or client.Character.HasJob("warden"))
end

category.Products = {
    {
        Name = "Firemans Carry Talent",
        Price = 350,
        Limit = 1,
        IsLimitGlobal = false,
        Action = function (client, product, items)
            client.Character.GiveTalent("firemanscarry")
        end
    },

    {
        Name = "Coilgun Ammo",
        Price = 200,
        Limit = 5,
        IsLimitGlobal = false,
        Items = {"coilgunammobox"},
    },

    {
        Name = "Handcuffs",
        Price = 100,
        Limit = 5,
        IsLimitGlobal = false,
        Items = {"handcuffs"},
    },

    {
        Name = "Stun Baton",
        Price = 200,
        Limit = 2,
        IsLimitGlobal = false,
        Items = {"stunbaton", "batterycell"},
    },

    {
        Name = "Stun Gun",
        Price = 500,
        Limit = 1,
        IsLimitGlobal = false,
        Items = {"stungun", "stungundart", "stungundart", "stungundart", "stungundart"},
    },

    {
        Name = "Stun Gun Ammo (x4)",
        Price = 100,
        Limit = 1,
        IsLimitGlobal = false,
        Items = {"stungundart", "stungundart", "stungundart", "stungundart"},
    },

    {
        Name = "Revolver Ammo (x6)",
        Price = 250,
        Limit = 1,
        IsLimitGlobal = false,
        Items = {"revolverround", "revolverround","revolverround", "revolverround", "revolverround", "revolverround"},
    },

    {
        Name = "SMG Magazine (x2)",
        Price = 350,
        Limit = 5,
        IsLimitGlobal = false,
        Items = {"smgmagazine", "smgmagazine"},
    },

    {
        Name = "Shotgun Shells (x8)",
        Price = 300,
        Limit = 5,
        IsLimitGlobal = false,
        Items = {"shotgunshell", "shotgunshell", "shotgunshell", "shotgunshell", "shotgunshell", "shotgunshell", "shotgunshell", "shotgunshell"},
    },

    {
        Name = "Stun Grenade",
        Price = 400,
        Limit = 3,
        IsLimitGlobal = false,
        Items = {"stungrenade"},
    },

    {
        Name = "Flamer",
        Price = 800,
        Limit = 1,
        IsLimitGlobal = false,
        Items = {"flamer", "incendiumfueltank"},
    },

}

return categorylocal event = {}

event.Name = "ShadyMission"
event.MinRoundTime = 1
event.MaxRoundTime = 10
event.MinIntensity = 0.6
event.MaxIntensity = 1
event.ChancePerMinute = 0.05
event.OnlyOncePerRound = true

local textPromptUtils = require("textpromptutils")

event.Start = function ()
    if #Level.Loaded.Wrecks == 0 then return end

    local possibleTargets = {}

    for key, value in pairs(Client.ClientList) do
        local character = value.Character
        if character and not character.IsDead and character.Vitality > 50 then
            if not Traitormod.RoleManager.IsAntagonist(character) then
                table.insert(possibleTargets, value)
            end
        end
    end

    if #possibleTargets == 0 then
        return
    end

    local specialBeacon = nil

    local target = possibleTargets[math.random(1, #possibleTargets)]

    -- mountain
    textPromptUtils.Prompt(
    "You pickup a weird radio transmission, it sounds like they are looking for someone to do a job for them.",
    {"Answer", "Ignore"}, target, function (option)
        if option == 2 then
            event.End()
            return
        end

        textPromptUtils.Prompt(
            "\"Oh hello there! We are looking for someone to do a simple task for us. We are willing to pay up to 3000 points for it. Interested?\"",
            {"Sure! What's it?"}, target, function ()

                textPromptUtils.Prompt(
                    "\"In this area where your submarine is heading through, there's an old wrecked submarine where we need to place some supplies. Because we don't have the supplies available right now, you are going to need to get the supplies yourself. We are going to need at least 8 of any medical item, 4 oxygen tanks, 2 loaded firearms of any type and a special sonar beacon. We will be paying 1500 points for these supplies, if you add any other supplies, we will give you up to 1500 additional points.\"",
                    {"This sounds fishy, why would you want to put these supplies in a wrecked submarine?!"}, target, function (option)
                        textPromptUtils.Prompt(
                            "\"Now this is none of your business, will you do it or not?\"",
                            {"Accept the offer", "Deny the offer"}, target, function (option2)
                                if option2 == 2 then
                                    event.End()
                                    return
                                end

                                textPromptUtils.Prompt(
                                    "\"Great! Just put all the supplies and the special sonar beacon in a metal crate and leave it in the wreck.\"",
                                    {"I'll do my best"}, target, function (option2)
                                end)

                                Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("sonarbeacon"), target.Character.Inventory, nil, nil, function (item)
                                    specialBeacon = item

                                    item.Description = "‖color:gui.red‖It looks like this sonar beacon was modified.\nBehind it there's a note saying: \"8 medical items, 4 oxygen tanks and 2 loaded firearms.\"‖color:end‖"
                                    item.set_InventoryIconColor(Color(255, 0, 0))
                                    item.SpriteColor = Color(255, 0, 0, 255)
                                    local color = item.SerializableProperties[Identifier("SpriteColor")]
                                    Networking.CreateEntityEvent(item, Item.ChangePropertyEventData(color, item))
                                    local invColor = item.SerializableProperties[Identifier("InventoryIconColor")]
                                    Networking.CreateEntityEvent(item, Item.ChangePropertyEventData(invColor, item))

                                    Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("batterycell"), item.OwnInventory, nil, nil, function (batteryCell)
                                        batteryCell.NonPlayerTeamInteractable = true
                                        local prop = batteryCell.SerializableProperties[Identifier("NonPlayerTeamInteractable")]
                                        Networking.CreateEntityEvent(batteryCell, Item.ChangePropertyEventData(prop, batteryCell))
                                    end)
                                end)
                        end, "ShockJock")
                end, "ShockJock")
        end, "ShockJock")
    end, "ShockJock")

    local completed = false

    local timer = 0
    Hook.Add("think", "Traitormod.RandomEvents.ShadyMission", function ()
        if Timer.GetTime() < timer then return end
        timer = Timer.GetTime() + 1
        if completed then return end
        if specialBeacon == nil then return end

        local isOnWreck = false
        for key, value in pairs(Level.Loaded.Wrecks) do
            if value == specialBeacon.Submarine then
                isOnWreck = true
            end
        end
        if not isOnWreck then return end

        local parent = specialBeacon.ParentInventory

        if parent == nil then return end
        if LuaUserData.IsTargetType(parent.Owner, "Barotrauma.Character") then return end
        if parent.Owner.ParentInventory ~= nil then return end
        if parent.Owner.Prefab.Identifier ~= "metalcrate" then return end

        local oxygenTanks = 0
        local medicalItems = 0
        local firearms = 0

        local notCounted = {}
        for item in parent.AllItems do
            if item.Prefab.Identifier == "oxygentank" then
                oxygenTanks = oxygenTanks + 1
            elseif item.HasTag("medical") then
                medicalItems = medicalItems + 1
            elseif item.HasTag("weapon") and item.GetContainedItemConditionPercentage() > 0.5 then
                firearms = firearms + 1
            else
                notCounted[item] = true
            end
        end

        if oxygenTanks >= 4 and medicalItems >= 8 and firearms >= 2 then
            local baseAmount = 1500

            for item, _ in pairs(notCounted) do
                if item.Prefab.DefaultPrice ~= nil then
                    baseAmount = baseAmount + item.Prefab.DefaultPrice.Price / 2
                end
            end

            completed = true

            Traitormod.AwardPoints(target, baseAmount)
            Traitormod.SendMessage(target, "You have received " .. baseAmount .. " points.", "InfoFrameTabButton.Mission")

            local newSet = {}
            newSet.Name = target.Name
            newSet.Items = {}

            for item in parent.AllItems do
                local itemData = {}
                itemData.Id = item.Prefab.Identifier.Value
                itemData.SubItems = {}
                if item.OwnInventory then
                    for subItem in item.OwnInventory.AllItems do
                        table.insert(itemData.SubItems, {subItem.Prefab.Identifier.Value})
                    end
                end

                local terminal = item.GetComponentString("Terminal")
                if terminal then
                    itemData.ShowMessage = terminal.ShowMessage
                end

                table.insert(newSet.Items, itemData)
            end

            local data = Traitormod.GetMasterData("TraitorItemSets") or {}
            table.insert(data, newSet)
            Traitormod.SetMasterData("TraitorItemSets", data)

            --parent.Owner.NonInteractable = true
        end
    end)
end


event.End = function ()
    Hook.Remove("think", "Traitormod.RandomEvents.ShadyMission")
end

return eventlocal category = {}

category.Name = "Ships"
category.CanAccess = function(client)
    return client.Character and not client.Character.IsDead and client.Character.IsHuman and Traitormod.SubmarineBuilder ~= nil and Traitormod.SubmarineBuilder.IsActive()
end

category.Init = function ()
    if Traitormod.SubmarineBuilder then
        category.StreamChalkId = Traitormod.SubmarineBuilder.AddSubmarine(Traitormod.Path .. "/Submarines/Stream Chalk.sub", "[P]Stream Chalk")
        category.BarsukId = Traitormod.SubmarineBuilder.AddSubmarine("Content/Submarines/Barsuk.sub", "[P]Barsuk")
    end
end

local function CanBuy(id, client)
    local submarine = Traitormod.SubmarineBuilder.FindSubmarine(id)
    local position = client.Character.WorldPosition + Vector2(0, -submarine.Borders.Height)

    local levelWalls = Level.Loaded.GetTooCloseCells(position, submarine.Borders.Width)
    if #levelWalls > 0 then
        return false, "Cannot spawn ship, position is too close to a level wall."
    end

    for key, value in pairs(Submarine.Loaded) do
        if submarine ~= value then
            local maxDistance = (value.Borders.Width + submarine.Borders.Width) / 2
            if Vector2.Distance(value.WorldPosition, position) < maxDistance then
                return false, "Cannot spawn ship, position is too close to another submarine."
            end
        end
    end

    return true
end

local function SpawnSubmarine(id, client)
    local submarine = Traitormod.SubmarineBuilder.FindSubmarine(id)
    local position = client.Character.WorldPosition + Vector2(0, -submarine.Borders.Height)

    submarine.SetPosition(position)
    submarine.GodMode = false

    Traitormod.SubmarineBuilder.ResetSubmarineSteering(submarine)
    return submarine
end

category.Products = {
    {
        Name = "Stream Chalk",
        Price = 300,
        Limit = 1,
        IsLimitGlobal = true,

        Action = function (client, product, items)
            SpawnSubmarine(category.StreamChalkId, client)
        end,

        CanBuy = function (client, product)
            return CanBuy(category.StreamChalkId, client)
        end
    },

    {
        Name = "Barsuk",
        Price = 3000,
        Limit = 1,
        IsLimitGlobal = true,

        Action = function (client, product, items)
            local submarine = SpawnSubmarine(category.BarsukId, client)
            AutoItemPlacer.RegenerateLoot(submarine, nil)
        end,

        CanBuy = function (client, product)
            return CanBuy(category.BarsukId, client)
        end
    },
}

return categorylocal statistics = {}
statistics.stats = {}
local textPromptUtils = require("textpromptutils")

local ItemsShown = 30 -- Sets how many lines will be shown. Should not be much more than 50

if Traitormod.Config.PermanentStatistics and not File.Exists(Traitormod.Path .. "/Lua/stats.json") then
    File.Write(Traitormod.Path .. "/Lua/stats.json", "{}")
end 

local json = dofile(Traitormod.Path .. "/Lua/json.lua")
statistics.LoadData = function ()
    if Traitormod.Config.PermanentStatistics then
        statistics.stats = json.decode(File.Read(Traitormod.Path .. "/Lua/stats.json")) or {}
    else
        statistics.stats = {}
    end
end

statistics.SaveData = function ()
    if Traitormod.Config.PermanentStatistics then
        File.Write(Traitormod.Path .. "/Lua/stats.json", json.encode(statistics.stats))
    end
end

statistics.SetStat = function (category, key, value)
    if statistics.stats[category] == nil then statistics.stats[category] = {} end
    statistics.stats[category][key] = value
end

statistics.AddStat = function (category, key, value)
    if statistics.stats[category] == nil then statistics.stats[category] = {} end
    statistics.SetStat(category, key, (statistics.stats[category][key] or 0) + value)
    return statistics.stats[category][key]
end

statistics.GetStat = function (category, key)
    return statistics.stats[category][key]
end

statistics.SetListStat = function (category, key, value, name)
    if statistics.stats[category] == nil then 
        statistics.stats[category] = {}
    end

    if statistics.stats[category][key] == nil then 
        statistics.stats[category][key] = {} 
    end

    statistics.stats[category][key].Name = name or key
    statistics.stats[category][key].Score = value
end

statistics.AddListStat = function (category, key, value, name)
    local oldValue = 0
    if statistics.stats[category] and statistics.stats[category][key] then
        oldValue = statistics.stats[category][key].Score or 0
    end
    statistics.SetListStat(category, key, (oldValue + value), name)
end

statistics.AddClientStat = function(category, client, value)
    if client then
        statistics.AddListStat(category, client.SteamID, value, client.Name)
    else
        Traitormod.Error("AddClientStat failed for " .. category .. " - Client was null")
    end
end

statistics.AddCharacterStat = function(category, character, value)
    local client = Traitormod.FindClientCharacter(character)
    if client ~= nil then
        statistics.AddClientStat(category, client, value)
    end
end

statistics.ShowStats = function(client, category)
    local text = "No stats found."
    local elem = statistics.stats[category]

    if elem then
        local firstKey = next(elem)
        if firstKey ~= nil then
            local itemLimit = ItemsShown
            local compare = function(t,a,b) return t[b] < t[a] end
            local isTable = false
            local topic = category .. " - " .. (Traitormod.Language[category] or "Stats")
            text = ""

            if elem[firstKey] and type(elem[firstKey]) == "table" and elem[firstKey].Score ~= nil then
                compare = function(t,a,b) return t[b].Score < t[a].Score end
                isTable = true
            end

            for key, value in spairs(elem, compare) do
                if isTable then
                    text = text .. "\n" .. math.floor(value.Score) .. " - " .. (value.Name or key)
                else
                    text = text .. "\n" .. value .. " - " ..  key
                end

                itemLimit = itemLimit - 1
                if itemLimit == 0 then
                    break
                end
            end

            text = topic .. ":\n" .. text
        end
    end

    Traitormod.SendMessage(client, text)
end

Traitormod.AddCommand("!stats", function (client, args)
    if #args > 0 then
        statistics.ShowStats(client, args[1])
    else
        local text = "Available stats:\n"

        if next(statistics.stats) == nil  then
            text = "No statistics available yet. Go start a round to collect stats."
        else
            local options = {}
            if not client.InGame then
                for key, value in pairs(statistics.stats) do
                    text = text .. "\n>> " .. key
                end
                text = text .. "\n\nType '!stats [option]' to show statistics."
            elseif client.HasPermission(ClientPermissions.ConsoleCommands) then
                -- if in game show convenient prompt
                for key, value in pairs(statistics.stats) do
                    table.insert(options, key)
                end
                table.insert(options, "")
                table.insert(options, "")
                
                textPromptUtils.Prompt(text, options, client, function (id, client2)
                    statistics.ShowStats(client2, options[id])
                end)
                return true
            else
                text = "Statistics are not available in game. Use this command in the lobby."
            end
        end

        Traitormod.SendMessage(client, text)
    end

    return true
end)

function spairs(t, order)
    -- collect the keys
    local keys = {}
    for k in pairs(t) do keys[#keys+1] = k end

    -- if order function given, sort by it by passing the table and keys a, b,
    -- otherwise just sort the keys 
    if order then
        table.sort(keys, function(a,b) return order(t, a, b) end)
    else
        table.sort(keys)
    end

    -- return the iterator function
    local i = 0
    return function()
        i = i + 1
        if keys[i] then
            return keys[i], t[keys[i]]
        end
    end
end

statistics.LoadData()
Traitormod.Stats = statisticslocal objective = Traitormod.RoleManager.Objectives.Objective:new()

objective.Name = "StealCaptainID"
objective.RoleFilter = {["captain"] = true}
objective.AmountPoints = 1300

function objective:Start(target)
    -- if no valid captain found, abort
    if not target then
        return false
    end

    self.Text = Traitormod.Language.ObjectiveStealCaptainID

    return true
end

function objective:IsCompleted()
    for item in self.Character.Inventory.AllItems do
        if item.Prefab.Identifier == "idcard" and item.GetComponentString("IdCard").OwnerJobId == "captain" then
            return true
        end
    end

    return false
end

return objective---@class StringBuilder : tablelib
-- "Utility class for building strings. This is a pure Lua implementation of the StringBuilder class in C#."
-- - Github Copilot
local p = setmetatable({}, {__index=table})

---@type string s
---@vararg string, format arguments
function p:format(s, ...)
    table.insert(self, string.format(type(s) ~= "table" and s or table.concat(s), ...))
    return self
end

function p:append(...)
    table.insert(self, table.concat(table.pack(...)))
    return self
end

---@return StringBuilder
function p:new()
    return setmetatable({}, {
        __call=self.format,
        __index=self,
    })
end

return plocal sb = {}

local linkedSubmarineHeader = [[<LinkedSubmarine description="" checkval="2040186250" price="1000" initialsuppliesspawned="false" type="Player" tags="Shuttle" gameversion="0.17.4.0" dimensions="1270,451" cargocapacity="0" recommendedcrewsizemin="1" recommendedcrewsizemax="2" recommendedcrewexperience="Unknown" requiredcontentpackages="Vanilla" name="%s" filepath="Content/Submarines/Selkie.sub" pos="-64,-392.5" linkedto="4" originallinkedto="0" originalmyport="0">%s</LinkedSubmarine>]]

sb.IsActive = function ()
    return Game.GetRespawnSub() ~= nil
end

sb.UpdateLobby = function(submarineInfo)
    local submarines = Game.NetLobbyScreen.subs

    for key, value in pairs(submarines) do
        if value.Name == "submarineinjector" then
            table.remove(submarines, key)
        end
    end

    table.insert(submarines, submarineInfo)
    SubmarineInfo.AddToSavedSubs(submarineInfo)

    Game.NetLobbyScreen.subs = submarines
    Game.NetLobbyScreen.SelectedShuttle = submarineInfo

    for _, client in pairs(Client.ClientList) do
        client.LastRecvLobbyUpdate = 0
        Networking.ClientWriteLobby(client)
    end
end

sb.Submarines = {}

sb.AddSubmarine = function (path, name)
    local submarineInfo = SubmarineInfo(path)

    name = name or submarineInfo.Name

    local xml = tostring(submarineInfo.SubmarineElement)

    local _, endPos = string.find(xml, ">")
    local startPos, _ = string.find(xml, "</Submarine>")

    local data = string.sub(xml, endPos + 1, startPos - 1)

    table.insert(sb.Submarines, {Name = name, Data = data})

    return name
end

sb.FindSubmarine = function (name)
    for _, submarine in pairs(Submarine.Loaded) do
        if submarine.Info.Name == name then
            return submarine
        end
    end
end

sb.ResetSubmarineSteering = function (submarine)
    for _, item in pairs(submarine.GetItems(true)) do
        local steering = item.GetComponentString("Steering")
        if steering then
            steering.AutoPilot = true
            steering.MaintainPos = true
            steering.PosToMaintain = submarine.WorldPosition
            steering.UnsentChanges = true
        end
    end
end

sb.BuildSubmarines = function()
    local submarineInjector = File.Read(Traitormod.Path .. "/Submarines/submarineinjector.xml")
    local result = ""

    for k, v in pairs(sb.Submarines) do
        result = result .. string.format(linkedSubmarineHeader, v.Name, v.Data)
    end

    local submarineText = string.format(submarineInjector, result)

    File.Write(Traitormod.Path .. "/Submarines/temp.xml", submarineText)
    local submarineInfoXML = SubmarineInfo(Traitormod.Path .. "/Submarines/temp.xml")
    submarineInfoXML.SaveAs(Traitormod.Path .. "/Submarines/temp.sub")

    local submarineInfo = SubmarineInfo(Traitormod.Path .. "/Submarines/temp.sub")

    sb.UpdateLobby(submarineInfo)
end

Hook.HookMethod("Barotrauma.Networking.GameServer", "TryStartGame", {}, function ()
    sb.BuildSubmarines()
end)

Hook.Add("roundStart", "SubmarineBuilder.RoundStart", function ()
    if Game.GetRespawnSub() == nil then return end

    for _, item in pairs(Game.GetRespawnSub().GetItems(false)) do
        local dockingPort = item.GetComponentString("DockingPort")
        if dockingPort then
            dockingPort.Undock()
        end
    end

    local xPosition = 0
    local yPosition = Level.Loaded.Size.Y + 10000

    for _, value in pairs(sb.Submarines) do
        local submarine = sb.FindSubmarine(value.Name)

        if submarine then
            xPosition = xPosition + submarine.Borders.Width * 2
            submarine.SetPosition(Vector2(xPosition, yPosition))
            submarine.GodMode = true
        end

        sb.ResetSubmarineSteering(submarine)
    end
end)

return sblocal event = {}

event.Name = "SuperBallastFlora"
event.MinRoundTime = 5
event.MinIntensity = 0
event.MaxIntensity = 0.3
event.ChancePerMinute = 0.015
event.OnlyOncePerRound = true

event.PumpsToInfect = 8

event.Start = function ()
    local pumps = {}
    for key, value in pairs(Submarine.MainSub.GetItems(true)) do
        local pump = value.GetComponentString("Pump")
        if pump ~= nil then
            table.insert(pumps, pump)
        end
    end

    for i = 1, event.PumpsToInfect, 1 do
        if #pumps > 0 then
            local index = math.random(#pumps)
            local pump = pumps[index]
            table.remove(pumps, index)

            pump.InfectBallast("ballastflora", true)
            pump.Item.CreateServerEvent(pump, pump)
        end
    end

    local text = "High concentration of ballast flora spores has been detected in this area, it's advised to search pumps for ballast flora!"
    Traitormod.RoundEvents.SendEventMessage(text, "EndRoundButton")

    event.End()
end


event.End = function ()

end

return eventlocal objective = Traitormod.RoleManager.Objectives.Objective:new()

objective.Name = "Survive"
objective.Text = Traitormod.Language.ObjectiveSurvive
objective.EndRoundObjective = true
objective.AlwaysActive = true
objective.AmountPoints = 500
objective.AmountLives = 1


function objective:Start()
    return true
end

function objective:IsCompleted()
    local role = Traitormod.RoleManager.GetRole(self.Character)

    if role == nil then return false end

    local anyObjective = false
    for key, value in pairs(role.Objectives) do
        if value.Awarded then anyObjective = true end
    end

    return anyObjective and not self.Character.IsDead
end

return objectivelocal c = {}

local promptIDToCallback = {}

local function SendEventMessage(msg, options, id, eventSprite, fadeToBlack, client)
    local message = Networking.Start()
    message.WriteByte(Byte(18)) -- net header
    message.WriteByte(Byte(0)) -- conversation

    message.WriteUInt16(UShort(id)) -- ushort identifier 0
    message.WriteString(eventSprite) -- event sprite
    message.WriteByte(Byte(0)) -- dialog Type
    message.WriteBoolean(false) -- continue conversation

    message.WriteUInt16(UShort(0)) -- speak Id
    message.WriteString(msg)
    message.WriteBoolean(fadeToBlack or false) -- fade to black
    message.WriteByte(Byte(#options))
    for key, value in pairs(options) do
        message.WriteString(value)
    end
    message.WriteByte(Byte(#options))
    for i = 0, #options - 1, 1 do
        message.WriteByte(Byte(i))
    end

    Networking.Send(message, client.Connection, DeliveryMethod.Reliable)
end


Hook.Add("netMessageReceived", "Traitormod.promptResponse", function (msg, header, client)
    if header == ClientPacketHeader.EVENTMANAGER_RESPONSE then 
        local id = msg.ReadUInt16()
        local option = msg.ReadByte()

        if promptIDToCallback[id] ~= nil then
            promptIDToCallback[id](option + 1, client)
            promptIDToCallback[id] = nil
        end

        msg.BitPosition = msg.BitPosition - (8 * 3) -- rewind 3 bytes from the message, so it can be read again
    end
end)

c.Prompt = function (message, options, client, callback, eventSprite, fadeToBlack)
    local currentPromptID = math.floor(math.random(0,65535))

    promptIDToCallback[currentPromptID] = callback
    SendEventMessage(message, options, currentPromptID, eventSprite, fadeToBlack, client)
end

return clocal category = {}

category.Name = "Traitor"
category.Decoration = "clown"
category.FadeToBlack = true

category.CanAccess = function(client)
    return client.Character and not client.Character.IsDead and Traitormod.RoleManager.HasRole(client.Character, "Traitor")
end

Hook.Patch("Barotrauma.Items.Components.Projectile", "HandleProjectileCollision", function (instance, ptable)
    local target = ptable["target"]

    if not instance.Launcher then return end
    if not instance.Launcher.HasTag("teleporter") then return end
    if instance.User == nil then return end
    if target == nil then return end
    if target.Body == nil then return end

    if tostring(target.Body.UserData) == "Barotrauma.Limb" then
        local character = target.Body.UserData.character

        local oldPosition = instance.User.WorldPosition
        instance.User.TeleportTo(character.WorldPosition)
        character.TeleportTo(oldPosition)
    else
        instance.User.TeleportTo(instance.Item.WorldPosition)
    end
end)

category.Products = {
    {
        Name = "Explosive Auto-Injector",
        Price = 2500,
        Limit = 1,
        IsLimitGlobal = false,
        Action = function (client)
            local prefabInjector = ItemPrefab.GetItemPrefab("autoinjectorheadset")
            local prefabUEX = ItemPrefab.GetItemPrefab("uex")
            Entity.Spawner.AddItemToSpawnQueue(prefabInjector, client.Character.Inventory, nil, nil, function (item)
                Entity.Spawner.AddItemToSpawnQueue(prefabUEX, client.Character.Inventory, nil, nil, function (item2)
                    item2.Tags = "medical"
                    item2.Description = "A modified UEX that can be put inside an Auto-Injector headset."
                    item2.set_InventoryIconColor(Color(0, 0, 255))
                    item2.SpriteColor = Color(0, 0, 255, 255)

                    local color = item2.SerializableProperties[Identifier("SpriteColor")]
                    Networking.CreateEntityEvent(item2, Item.ChangePropertyEventData(color, item2))            
                    local invColor = item2.SerializableProperties[Identifier("InventoryIconColor")]
                    Networking.CreateEntityEvent(item2, Item.ChangePropertyEventData(invColor, item2))
                end)
            end)
        end
    },

    {
        Name = "Invisibility Gear",
        Price = 800,
        Limit = 1,
        IsLimitGlobal = false,
        Action = function (client)
            local suit = ItemPrefab.GetItemPrefab("divingsuit")
            Entity.Spawner.AddItemToSpawnQueue(suit, client.Character.Inventory, nil, nil, function (item)
                local light = item.GetComponentString("LightComponent")

                item.set_InventoryIconColor(Color(100, 100, 100, 50))
                item.SpriteColor = Color(0, 0, 0, 0)
                item.Tags = "smallitem"
                light.LightColor = Color(0, 0, 0, 0)

                local color = item.SerializableProperties[Identifier("SpriteColor")]
                Networking.CreateEntityEvent(item, Item.ChangePropertyEventData(color, item))            
                local invColor = item.SerializableProperties[Identifier("InventoryIconColor")]
                Networking.CreateEntityEvent(item, Item.ChangePropertyEventData(invColor, item))
                local lightColor = light.SerializableProperties[Identifier("LightColor")]
                Networking.CreateEntityEvent(item, Item.ChangePropertyEventData(lightColor, light))

                Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("oxygentank"), item.OwnInventory)
            end)

            local robes = ItemPrefab.GetItemPrefab("cultistrobes")
            Entity.Spawner.AddItemToSpawnQueue(robes, client.Character.Inventory, nil, nil, function (item)

                item.set_InventoryIconColor(Color(100, 100, 100, 50))
                item.SpriteColor = Color(0, 0, 0, 0)
                item.Tags = "smallitem"

                local color = item.SerializableProperties[Identifier("SpriteColor")]
                Networking.CreateEntityEvent(item, Item.ChangePropertyEventData(color, item))            
                local invColor = item.SerializableProperties[Identifier("InventoryIconColor")]
                Networking.CreateEntityEvent(item, Item.ChangePropertyEventData(invColor, item))
            end)

            local cap = ItemPrefab.GetItemPrefab("ironhelmet")
            Entity.Spawner.AddItemToSpawnQueue(cap, client.Character.Inventory, nil, nil, function (item)

                item.set_InventoryIconColor(Color(100, 100, 100, 50))
                item.SpriteColor = Color(0, 0, 0, 0)
                item.Tags = "smallitem"

                local color = item.SerializableProperties[Identifier("SpriteColor")]
                Networking.CreateEntityEvent(item, Item.ChangePropertyEventData(color, item))            
                local invColor = item.SerializableProperties[Identifier("InventoryIconColor")]
                Networking.CreateEntityEvent(item, Item.ChangePropertyEventData(invColor, item))
            end)
        end
    },

    {
        Name = "Teleporter Revolver",
        Price = 1800,
        Limit = 1,
        IsLimitGlobal = false,
        Action = function (client)
            local revolver = ItemPrefab.GetItemPrefab("revolver")
            Entity.Spawner.AddItemToSpawnQueue(revolver, client.Character.Inventory, nil, nil, function (item)
                item.Tags = "teleporter"
                item.Description = "‖color:gui.red‖A special revolver with teleportation features...‖color:end‖"

                item.set_InventoryIconColor(Color(0, 0, 255, 255))
                item.SpriteColor = Color(0, 0, 255, 255)

                local color = item.SerializableProperties[Identifier("SpriteColor")]
                Networking.CreateEntityEvent(item, Item.ChangePropertyEventData(color, item))            
                local invColor = item.SerializableProperties[Identifier("InventoryIconColor")]
                Networking.CreateEntityEvent(item, Item.ChangePropertyEventData(invColor, item))

                for i = 1, 6, 1 do
                    Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("revolverround"), item.OwnInventory)
                end
            end)
        end
    },

    {
        Name = "Boom Stick",
        Price = 3200,
        Limit = 1,
        IsLimitGlobal = false,
        Items = {"shotgununique", 
        "shotgunshell", "shotgunshell", "shotgunshell", "shotgunshell", "shotgunshell", "shotgunshell", "shotgunshell", "shotgunshell","shotgunshell", "shotgunshell", "shotgunshell", "shotgunshell", "shotgunshell", "shotgunshell", "shotgunshell", "shotgunshell"},
    },

    {
        Name = "Shotgun Shell (x8)",
        Price = 320,
        Limit = 5,
        IsLimitGlobal = false,
        Items = {"shotgunshell", "shotgunshell", "shotgunshell", "shotgunshell", "shotgunshell", "shotgunshell", "shotgunshell", "shotgunshell"},
    },

    {
        Name = "Deadeye Carbine",
        Price = 2900,
        Limit = 1,
        IsLimitGlobal = false,
        Items = {"smgunique", "smgmagazine", "smgmagazine"},
    },

    {
        Name = "SMG Magazine",
        Price = 250,
        Limit = 5,
        IsLimitGlobal = false,
        Items = {"smgmagazine"},
    },

    {
        Name = "Prototype Steam Cannon",
        Price = 1300,
        Limit = 1,
        IsLimitGlobal = false,
        Items = {"flamerunique", "incendiumfueltank"},
    },

    {
        Name = "Detonator",
        Price = 950,
        Limit = 3,
        IsLimitGlobal = false,
        Items = {"detonator"},
    },

    {
        Name = "UEX",
        Price = 700,
        Limit = 5,
        IsLimitGlobal = false,
        Items = {"uex"},
    },

    {
        Name = "Molotov",
        Price = 950,
        Limit = 5,
        IsLimitGlobal = false,
        Items = {"molotovcoctail"},
    },

    {
        Name = "Stun Grenade",
        Price = 600,
        Limit = 3,
        IsLimitGlobal = false,
        Items = {"stungrenade"},
    },

    {
        Name = "Mutated Pomegrenade",
        Price = 530,
        Limit = 3,
        IsLimitGlobal = false,
        Items = {"badcreepingorange"},
    },

    {
        Name = "Turn Off Lights For 3 Minutes",
        Price = 350,
        Limit = 1,
        IsLimitGlobal = true,

        CanBuy = function (client, product)
            return not Traitormod.RoundEvents.IsEventActive("LightsOff")
        end,

        Action = function ()
            Traitormod.RoundEvents.TriggerEvent("LightsOff")
        end
    },

    {
        Name = "Turn Off Communications For 2 Minutes",
        Price = 400,
        Limit = 1,
        IsLimitGlobal = true,

        CanBuy = function (client, product)
            return not Traitormod.RoundEvents.IsEventActive("CommunicationsOffline")
        end,

        Action = function ()
            Traitormod.RoundEvents.TriggerEvent("CommunicationsOffline")
        end
    },

    {
        Name = "Sabotage Oxygen Generator",
        Price = 2500,
        Limit = 1,
        IsLimitGlobal = true,

        CanBuy = function (client, product)
            return not Traitormod.RoundEvents.IsEventActive("OxygenGeneratorPoison")
        end,

        Action = function ()
            Traitormod.RoundEvents.TriggerEvent("OxygenGeneratorPoison")
        end
    },
}

return categorydofile(Traitormod.Path .. "/Lua/traitormodutil.lua")

Game.OverrideTraitors(true)

if Traitormod.Config.RagdollOnDisconnect ~= nil then
    Game.DisableDisconnectCharacter(not Traitormod.Config.RagdollOnDisconnect)
end

if Traitormod.Config.EnableControlHusk ~= nil then
    Game.EnableControlHusk(Traitormod.Config.EnableControlHusk)
end

math.randomseed(os.time())

Traitormod.Gamemodes = {}

Traitormod.AddGamemode = function(gamemode)
    Traitormod.Gamemodes[gamemode.Name] = gamemode

    if Traitormod.Config.GamemodeConfig[gamemode.Name] ~= nil then
        for key, value in pairs(Traitormod.Config.GamemodeConfig[gamemode.Name]) do
            gamemode[key] = value
        end
    end
end

if not File.Exists(Traitormod.Path .. "/Lua/data.json") then
    File.Write(Traitormod.Path .. "/Lua/data.json", "{}")
end

Traitormod.RoundNumber = 0
Traitormod.RoundTime = 0
Traitormod.LostLivesThisRound = {}
Traitormod.Commands = {}

local pointsGiveTimer = -1

Traitormod.LoadData()

if Traitormod.Config.RemotePoints then
    for key, value in pairs(Client.ClientList) do
        Traitormod.LoadRemoteData(value)
    end
end

Traitormod.RoundStart = function()
    Traitormod.Log("Starting traitor round - Traitor Mod v" .. Traitormod.VERSION)
    pointsGiveTimer = Timer.GetTime() + Traitormod.Config.ExperienceTimer

    Traitormod.CodeWords = Traitormod.SelectCodeWords()

    -- give XP to players based on stored points
    for key, value in pairs(Client.ClientList) do
        if value.Character ~= nil then
            Traitormod.SetData(value, "Name", value.Character.Name)
        end

        if not value.SpectateOnly then
            Traitormod.LoadExperience(value)
        else
            Traitormod.Debug("Skipping load experience for spectator " .. value.Name)
        end

        -- Send Welcome message
        Traitormod.SendWelcome(value)
    end

    local function startsWith(String, Start)
        return string.sub(String, 1, string.len(Start)) == Start
    end

    if Traitormod.Config.RemoveSkillBooks then
        for key, value in pairs(Item.ItemList) do
            if startsWith(value.Prefab.Identifier.Value, "skillbook") then
                Entity.Spawner.AddEntityToRemoveQueue(value)
            end
        end
    end


    Traitormod.SelectedGamemode = nil

    if LuaUserData.IsTargetType(Game.GameSession.GameMode, "Barotrauma.PvPMode") then
        Traitormod.SelectedGamemode = Traitormod.Gamemodes.PvP:new()
    elseif LuaUserData.IsTargetType(Game.GameSession.GameMode, "Barotrauma.CampaignMode") then
        Traitormod.SelectedGamemode = Traitormod.Gamemodes.Gamemode:new()
    elseif Game.ServerSettings.TraitorsEnabled == 1 and math.random() > 0.5 then
        Traitormod.SelectedGamemode = Traitormod.Gamemodes.Secret:new()
    elseif Game.ServerSettings.TraitorsEnabled == 2 then
        Traitormod.SelectedGamemode = Traitormod.Gamemodes.Secret:new()
    end

    if Traitormod.SelectedGamemode == nil then
        Traitormod.Log("No gamemode selected!")
        return
    end

    Traitormod.Log("Starting gamemode " .. Traitormod.SelectedGamemode.Name)

    if Traitormod.SelectedGamemode then
        Traitormod.SelectedGamemode:Start()
    end
end

Hook.Add("roundStart", "Traitormod.RoundStart", function()
    Traitormod.RoundStart()
end)

Hook.Add("missionsEnded", "Traitormod.MissionsEnded", function(missions)
    Traitormod.RoundMissions = missions
    Traitormod.Debug("missionsEnded with " .. #Traitormod.RoundMissions .. " missions.")

    for key, value in pairs(Client.ClientList) do
        -- add weight according to points and config conversion
        Traitormod.AddData(value, "Weight", Traitormod.Config.AmountWeightWithPoints(Traitormod.GetData(value, "Points") or 0))
    end

    Traitormod.Debug("Round " .. Traitormod.RoundNumber .. " ended.")
    Traitormod.RoundNumber = Traitormod.RoundNumber + 1
    Traitormod.Stats.AddStat("Rounds", "Rounds finished", 1)

    Traitormod.PointsToBeGiven = {}
    Traitormod.AbandonedCharacters = {}
    Traitormod.PointItems = {}
    Traitormod.RoundTime = 0
    Traitormod.LostLivesThisRound = {}

    local endMessage = ""
    if Traitormod.SelectedGamemode then
        endMessage = Traitormod.SelectedGamemode:RoundSummary()

        Traitormod.SendMessageEveryone(Traitormod.HighlightClientNames(endMessage, Color.Red))
    end
    Traitormod.LastRoundSummary = endMessage

    if Traitormod.SelectedGamemode then
        Traitormod.SelectedGamemode:End(missions)
    end

    Traitormod.RoleManager.EndRound()
    Traitormod.RoundEvents.EndRound()

    Traitormod.SelectedGamemode = nil

    Traitormod.SaveData()
    Traitormod.Stats.SaveData()

    if Traitormod.Config.RemotePoints then
        for key, value in pairs(Client.ClientList) do
            Traitormod.PublishRemoteData(value)
        end
    end
end)

Hook.Add("roundEnd", "Traitormod.RoundEnd", function()
    if Traitormod.SelectedGamemode then
        return Traitormod.SelectedGamemode:TraitorResults()
    end
end)

Hook.Add("characterCreated", "Traitormod.CharacterCreated", function(character)
    -- if character is valid player
    if character == nil or
        character.IsBot == true or
        character.IsHuman == false or
        character.ClientDisconnected == true then
        return
    end

    -- delay handling, otherwise client won't be found
    Timer.Wait(function()
        local client = Traitormod.FindClientCharacter(character)
        
        Traitormod.Stats.AddClientStat("Spawns", client, 1)

        if client ~= nil then
            -- set experience of respawned character to stored value - note initial spawn may not call this hook (on local server)
            Traitormod.LoadExperience(client)
        else
            Traitormod.Error("Loading experience on characterCreated failed! Client was nil after 1sec")
        end
    end, 1000)
end)

local tipDelay = 0

-- register tick
Hook.Add("think", "Traitormod.Think", function()
    if Timer.GetTime() > tipDelay then
        tipDelay = Timer.GetTime() + 500
        Traitormod.SendTip()
    end

    if not Game.RoundStarted or Traitormod.SelectedGamemode == nil then
        return
    end

    Traitormod.RoundTime = Traitormod.RoundTime + 1 / 60

    if Traitormod.SelectedGamemode then
        Traitormod.SelectedGamemode:Think()
    end

    -- every 60s, if a character has 100+ PointsToBeGiven, store added points and send feedback
    if pointsGiveTimer and Timer.GetTime() > pointsGiveTimer then
        for key, value in pairs(Traitormod.PointsToBeGiven) do
            if value > 100 then
                local points = Traitormod.AwardPoints(key, value)
                if Traitormod.GiveExperience(key.Character, Traitormod.Config.AmountExperienceWithPoints(points)) then
                    local text = Traitormod.Language.SkillsIncreased ..
                        "\n" .. string.format(Traitormod.Language.PointsAwarded, math.floor(points))
                    Game.SendDirectChatMessage("", text, nil, Traitormod.Config.ChatMessageType, key)

                    Traitormod.PointsToBeGiven[key] = 0
                end
            end
        end

        -- if configured, give temporary experience to all characters
        if Traitormod.Config.FreeExperience and Traitormod.Config.FreeExperience > 0 then
            for key, value in pairs(Client.ClientList) do
                Traitormod.GiveExperience(value.Character, Traitormod.Config.FreeExperience)
            end
        end

        pointsGiveTimer = Timer.GetTime() + Traitormod.Config.ExperienceTimer
    end
end)

-- when a character gains skill level, add PointsToBeGiven according to config
Traitormod.PointsToBeGiven = {}
Hook.HookMethod("Barotrauma.CharacterInfo", "IncreaseSkillLevel", function(instance, ptable)
    if not ptable or ptable.gainedFromAbility or instance.Character == nil or instance.Character.IsDead then return end

    local client = Traitormod.FindClientCharacter(instance.Character)

    if client == nil then return end

    local points = Traitormod.Config.PointsGainedFromSkill[tostring(ptable.skillIdentifier)]

    if points == nil then return end

    points = points * ptable.increase

    Traitormod.PointsToBeGiven[client] = (Traitormod.PointsToBeGiven[client] or 0) + points
end)

Traitormod.AbandonedCharacters = {}
-- new player connected to the server
Hook.Add("clientConnected", "Traitormod.ClientConnected", function (client)
    if Traitormod.Config.RemotePoints then
        Traitormod.LoadRemoteData(client, function ()
            Traitormod.SendWelcome(client)
        end)
    else
        Traitormod.SendWelcome(client)
    end

    if Traitormod.AbandonedCharacters[client.SteamID] and Traitormod.AbandonedCharacters[client.SteamID].IsDead then
        -- client left while char was alive -> but char is dead, so adjust life
        Traitormod.Debug(string.format("%s connected, but his character died in the meantime...",
            Traitormod.ClientLogName(client)))

        local lifeMsg, lifeIcon = Traitormod.AdjustLives(client, -1)
        Traitormod.SendMessage(client, lifeMsg, lifeIcon)

        Traitormod.AbandonedCharacters[client.SteamID] = nil
    end
end)

-- player disconnected from server
Hook.Add("clientDisconnected", "Traitormod.ClientDisconnected", function (client)
    if Traitormod.Config.RemotePoints then
        Traitormod.PublishRemoteData(client)
    end

    -- if character was alive while disconnecting, make sure player looses live if he rejoins the round
    if client.Character and not client.Character.IsDead and client.Character.IsHuman then
        Traitormod.Debug(string.format("%s disconnected with an alive character. Remembering for rejoin...",
            Traitormod.ClientLogName(client)))
        Traitormod.AbandonedCharacters[client.SteamID] = client.Character
    end
end)

-- Traitormod.Commands hook
Hook.Add("chatMessage", "Traitormod.ChatMessage", function(message, client)
    local split = Traitormod.ParseCommand(message)

    if #split == 0 then return end

    local command = string.lower(table.remove(split, 1))

    if Traitormod.Commands[command] then
        Traitormod.Log(Traitormod.ClientLogName(client) .. " used command: " .. message)
        return Traitormod.Commands[command].Callback(client, split)
    end
end)


LuaUserData.MakeMethodAccessible(Descriptors["Barotrauma.Item"], "set_InventoryIconColor")

Traitormod.PointItems = {}
Traitormod.SpawnPointItem = function(inventory, amount, text, onSpawn, onUsed)
    text = text or ""

    Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("logbook"), inventory, nil, nil, function(item)
        Traitormod.PointItems[item] = {}
        Traitormod.PointItems[item].Amount = amount
        Traitormod.PointItems[item].OnUsed = onUsed

        local terminal = item.GetComponentString("Terminal")
        terminal.ShowMessage = text ..
            "\nThis LogBook contains " .. amount .. " points. Type \"claim\" into it to claim the points."
        terminal.SyncHistory()

        item.set_InventoryIconColor(Color(0, 0, 255))
        item.SpriteColor = Color(0, 0, 255, 255)
        item.Scale = 0.5

        local color = item.SerializableProperties[Identifier("SpriteColor")]
        Networking.CreateEntityEvent(item, Item.ChangePropertyEventData(color, item))

        local scale = item.SerializableProperties[Identifier("Scale")]
        Networking.CreateEntityEvent(item, Item.ChangePropertyEventData(scale, item))

        local invColor = item.SerializableProperties[Identifier("InventoryIconColor")]
        Networking.CreateEntityEvent(item, Item.ChangePropertyEventData(invColor, item))

        if onSpawn then
            onSpawn(item)
        end
    end)
end

Hook.Patch("Barotrauma.Items.Components.Terminal", "ServerEventRead", function(instance, ptable)
    local msg = ptable["msg"]
    local client = ptable["c"]

    local rewindBit = msg.BitPosition
    local output = msg.ReadString()
    msg.BitPosition = rewindBit -- this is so the game can still read the net message, as you cant read the same bit twice

    if output ~= "claim" then return end

    local item = instance.Item
    local data = Traitormod.PointItems[item]

    if data == nil then return end

    Traitormod.AwardPoints(client, data.Amount)
    Traitormod.SendMessage(client, "You have received " .. data.Amount .. " points.", "InfoFrameTabButton.Mission")

    if data.OnUsed then
        data.OnUsed(client)
    end

    local terminal = item.GetComponentString("Terminal")
    terminal.ShowMessage = "Claimed by " .. client.Name
    terminal.SyncHistory()

    Traitormod.PointItems[item] = nil

end, Hook.HookMethodType.Before)


if Traitormod.Config.OverrideRespawnSubmarine then
    Traitormod.SubmarineBuilder = dofile(Traitormod.Path .. "/Lua/submarinebuilder.lua")
end

Traitormod.StringBuilder = dofile(Traitormod.Path .. "/Lua/stringbuilder.lua")
Traitormod.Voting = dofile(Traitormod.Path .. "/Lua/voting.lua")
Traitormod.RoleManager = dofile(Traitormod.Path .. "/Lua/rolemanager.lua")
Traitormod.Pointshop = dofile(Traitormod.Path .. "/Lua/pointshop.lua")
Traitormod.RoundEvents = dofile(Traitormod.Path .. "/Lua/roundevents.lua")
Traitormod.GhostRoles = dofile(Traitormod.Path .. "/Lua/ghostroles.lua")

dofile(Traitormod.Path .. "/Lua/commands.lua")
dofile(Traitormod.Path .. "/Lua/statistics.lua")
dofile(Traitormod.Path .. "/Lua/respawnshuttle.lua")
dofile(Traitormod.Path .. "/Lua/traitormodmisc.lua")

Traitormod.AddGamemode(dofile(Traitormod.Path .. "/Lua/gamemodes/gamemode.lua"))
Traitormod.AddGamemode(dofile(Traitormod.Path .. "/Lua/gamemodes/secret.lua"))
Traitormod.AddGamemode(dofile(Traitormod.Path .. "/Lua/gamemodes/pvp.lua"))

Traitormod.RoleManager.AddObjective(dofile(Traitormod.Path .. "/Lua/objectives/objective.lua"))
Traitormod.RoleManager.AddObjective(dofile(Traitormod.Path .. "/Lua/objectives/assassinate.lua"))
Traitormod.RoleManager.AddObjective(dofile(Traitormod.Path .. "/Lua/objectives/kidnap.lua"))
Traitormod.RoleManager.AddObjective(dofile(Traitormod.Path .. "/Lua/objectives/poisoncaptain.lua"))
Traitormod.RoleManager.AddObjective(dofile(Traitormod.Path .. "/Lua/objectives/stealcaptainid.lua"))
Traitormod.RoleManager.AddObjective(dofile(Traitormod.Path .. "/Lua/objectives/survive.lua"))
Traitormod.RoleManager.AddObjective(dofile(Traitormod.Path .. "/Lua/objectives/husk.lua"))
Traitormod.RoleManager.AddObjective(dofile(Traitormod.Path .. "/Lua/objectives/turnhusk.lua"))
Traitormod.RoleManager.AddObjective(dofile(Traitormod.Path .. "/Lua/objectives/destroycaly.lua"))
Traitormod.RoleManager.AddObjective(dofile(Traitormod.Path .. "/Lua/objectives/crew/killmonsters.lua"))
Traitormod.RoleManager.AddObjective(dofile(Traitormod.Path .. "/Lua/objectives/crew/repair.lua"))
Traitormod.RoleManager.AddObjective(dofile(Traitormod.Path .. "/Lua/objectives/save.lua"))

Traitormod.RoleManager.AddRole(dofile(Traitormod.Path .. "/Lua/roles/role.lua"))
Traitormod.RoleManager.AddRole(dofile(Traitormod.Path .. "/Lua/roles/antagonist.lua"))
Traitormod.RoleManager.AddRole(dofile(Traitormod.Path .. "/Lua/roles/traitor.lua"))
Traitormod.RoleManager.AddRole(dofile(Traitormod.Path .. "/Lua/roles/cultist.lua"))
Traitormod.RoleManager.AddRole(dofile(Traitormod.Path .. "/Lua/roles/huskservant.lua"))
Traitormod.RoleManager.AddRole(dofile(Traitormod.Path .. "/Lua/roles/crew.lua"))

-- Round start call for reload during round
if Game.RoundStarted then
    Traitormod.RoundStart()
end
local timer = Timer.GetTime()

local peopleInOutpost = 0

local n = 1
Hook.Add("think", "Traitormod.MiscThink", function ()
    if timer > Timer.GetTime() then return end
    if not Game.RoundStarted then return end

    timer = Timer.GetTime() + 5

    if Traitormod.Config.GhostRoleConfig.Enabled then
        for key, character in pairs(Character.CharacterList) do
            if not Traitormod.GhostRoles.IsGhostRole(character) then
                if Traitormod.Config.GhostRoleConfig.MiscGhostRoles[character.SpeciesName.Value] then
                    Traitormod.GhostRoles.Ask(character.Name .. " " .. n, function (client)
                        client.SetClientCharacter(character)
                    end, character)
                    n = n + 1
                end
            end
        end
    end

    if not Traitormod.RoundEvents.EventExists("OutpostPirateAttack") then return end
    if Traitormod.RoundEvents.IsEventActive("OutpostPirateAttack") then return end
    if Traitormod.SelectedGamemode == nil or Traitormod.SelectedGamemode.Name ~= "Secret" then return end

    local targets = {}
    local outpost = Level.Loaded.EndOutpost.WorldPosition

    for key, character in pairs(Character.CharacterList) do
        if character.IsRemotePlayer and character.IsHuman and not character.IsDead and Vector2.Distance(character.WorldPosition, outpost) < 5000 then
            table.insert(targets, character)
        end
    end

    if #targets > 0 then
        peopleInOutpost = peopleInOutpost + 1
    end

    if peopleInOutpost > 30 then
        Traitormod.RoundEvents.TriggerEvent("OutpostPirateAttack")
    end
end)

Hook.Add("roundEnd", "Traitormod.MiscEnd", function ()
    peopleInOutpost = 0
end)

if Traitormod.Config.NerfSwords then
    local replacement = [[
    <overwrite>
        <Attack targetimpulse="2" severlimbsprobability="0.55" itemdamage="10" structuredamage="1" structuresoundtype="StructureSlash">
            <Affliction identifier="lacerations" strength="5" />
            <Affliction identifier="bleeding" strength="25" />
            <Affliction identifier="stun" strength="0.01" />
        </Attack>
    </overwrite>
    ]]

    local husk = ItemPrefab.GetItemPrefab("ceremonialsword")
    local element = husk.ConfigElement.Element.Element("MeleeWeapon")
    Traitormod.Patching.RemoveAll(element, "Attack")
    Traitormod.Patching.Add(element, replacement)
end

if Traitormod.Config.DeathLogBook then
    local messages = {}

    Hook.Add("roundEnd", "Traitormod.DeathLogBook", function ()
        messages = {}
    end)

    Hook.Add("character.death", "Traitormod.DeathLogBook", function (character)
        if messages[character] == nil then return end

        Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("logbook"), character.Inventory, nil, nil, function(item)
            local terminal = item.GetComponentString("Terminal")

            local text = ""
            for key, value in pairs(messages[character]) do
                text = text .. value .. "\n"
            end

            terminal.TextColor = Color.MidnightBlue
            terminal.ShowMessage = text
            terminal.SyncHistory()
        end)
    end)

    Traitormod.AddCommand("!write", function (client, args)
        if client.Character == nil or client.Character.IsDead or client.Character.SpeechImpediment > 0 or not client.Character.IsHuman then
            Traitormod.SendChatMessage(client, "You are unable to write to your death logbook.", Color.Red)
            return true
        end

        if messages[client.Character] == nil then
            messages[client.Character] = {}
        end

        if #messages[client.Character] > 255 then return end

        local message = table.concat(args, " ")
        table.insert(messages[client.Character], message)

        Traitormod.SendChatMessage(client, "Wrote \"" .. message .. "\" to the death logbook.", Color.Green)

        return true
    end)
end

Hook.Add("roundEnd", "ConvictEscape", function ()
    for key, plr in pairs(Client.ClientList) do
        if plr.Character and not plr.Character.IsDead and plr.Character.IsHuman and plr.Character.JobIdentifier == "convict" and plr.Character.Submarine ~= Submarine.MainSub then
            Traitormod.AwardPoints(plr, 2100)
            Traitormod.SendMessage(plr, "Congrats on escaping, you have received 2100 points.", "InfoFrameTabButton.Mission")
        end
    end
end)MissionType = LuaUserData.CreateEnumTable("Barotrauma.MissionType")

Traitormod.Config = dofile(Traitormod.Path .. "/Lua/config/config.lua")
Traitormod.Patching = loadfile(Traitormod.Path .. "/Lua/xmlpatching.lua")(Traitormod.Path)

Traitormod.Languages = {
    dofile(Traitormod.Path .. "/Lua/language/english.lua")
}

Traitormod.Language = Traitormod.Languages[1]

for key, value in pairs(Traitormod.Languages) do
    if Traitormod.Config.Language == value.Name then
        Traitormod.Language = value
    end
end

local json = dofile(Traitormod.Path .. "/Lua/json.lua")

Traitormod.LoadRemoteData = function (client, loaded)
    local data = {
        Account = client.SteamID,
    }

    for key, value in pairs(Traitormod.Config.RemoteServerAuth) do
        data[key] = value
    end

    Networking.HttpPost(Traitormod.Config.RemotePoints, function (res) 
        local success, result = pcall(json.decode, res)
        if not success then
            Traitormod.Log("Failed to retrieve points from server: " .. res)
            return
        end

        if result.Points then
            local originalPoints = Traitormod.GetData(client, "Points") or 0
            Traitormod.Log("Retrieved points from server for " .. client.SteamID .. ": " .. originalPoints .. " -> " .. result.Points)
            Traitormod.SetData(client, "Points", result.Points)
        end

        if loaded then loaded() end
    end, json.encode(data))
end

Traitormod.PublishRemoteData = function (client)
    local data = {
        Account = client.SteamID,
        Points = Traitormod.GetData(client, "Points")
    }

    if data.Points == nil then return end

    Traitormod.Log("Published points from server for " .. client.SteamID .. ": " .. data.Points)

    for key, value in pairs(Traitormod.Config.RemoteServerAuth) do
        data[key] = value
    end

    Networking.HttpPost(Traitormod.Config.RemotePoints, function (res) end, json.encode(data))
end

Traitormod.LoadData = function ()
    if Traitormod.Config.PermanentPoints then
        Traitormod.ClientData = json.decode(File.Read(Traitormod.Path .. "/Lua/data.json")) or {}
    else
        Traitormod.ClientData = {}
    end
end

Traitormod.SaveData = function ()
    if Traitormod.Config.PermanentPoints then
        File.Write(Traitormod.Path .. "/Lua/data.json", json.encode(Traitormod.ClientData))
    end
end

Traitormod.SetMasterData = function (name, value)
    Traitormod.ClientData[name] = value
end

Traitormod.GetMasterData = function (name)
    return Traitormod.ClientData[name]
end

Traitormod.SetData = function (client, name, amount)
    if Traitormod.ClientData[client.SteamID] == nil then 
        Traitormod.ClientData[client.SteamID] = {}
    end

    Traitormod.ClientData[client.SteamID][name] = amount
end

Traitormod.GetData = function (client, name)
    if Traitormod.ClientData[client.SteamID] == nil then 
        Traitormod.ClientData[client.SteamID] = {}
    end

    return Traitormod.ClientData[client.SteamID][name]
end

Traitormod.AddData = function(client, name, amount)
    Traitormod.SetData(client, name, math.max((Traitormod.GetData(client, name) or 0) + amount, 0))
end

Traitormod.FindClient = function (name)
    for key, value in pairs(Client.ClientList) do
        if value.Name == name or tostring(value.SteamID) == name then
            return value
        end
    end
end

Traitormod.FindClientCharacter = function (character)
    for key, value in pairs(Client.ClientList) do
        if character == value.Character then return value end
    end

    return nil
end

Traitormod.SendMessageEveryone = function (text, popup)
    if popup then
        Game.SendMessage(text, ChatMessageType.MessageBox)
    else
        Game.SendMessage(text, ChatMessageType.Server)
    end
end

Traitormod.SendMessage = function (client, text, icon)
    if not client or not text or text == "" then
        return
    end
    text = tostring(text)

    if icon then
        Game.SendDirectChatMessage("", text, nil, ChatMessageType.ServerMessageBoxInGame, client, icon)
    else
        Game.SendDirectChatMessage("", text, nil, ChatMessageType.MessageBox, client)
    end

    Game.SendDirectChatMessage("", text, nil, Traitormod.Config.ChatMessageType, client)
end

Traitormod.SendChatMessage = function (client, text, color)
    if not client or not text or text == "" then
        return
    end

    text = tostring(text)

    local chatMessage = ChatMessage.Create("", text, ChatMessageType.Default)
    if color then
        chatMessage.Color = color
    end

    Game.SendDirectChatMessage(chatMessage, client)
end

Traitormod.SendMessageCharacter = function (character, text, icon)
    if character.IsBot then return end
    
    local client = Traitormod.FindClientCharacter(character)

    if client == nil then
        Traitormod.Error("SendMessageCharacter() Client is null, ", character.name, " ", text)
        return
    end

    Traitormod.SendMessage(client, text, icon)
end

Traitormod.MissionIdentifier =  "easterbunny" -- can be any defined Traitor mission id in vanilla xml, mainly used for icon
Traitormod.SendTraitorMessageBox = function (client, text, icon)
    Game.SendTraitorMessage(client, text, icon or Traitormod.MissionIdentifier, TraitorMessageType.ServerMessageBox);
    Game.SendDirectChatMessage("", text, nil, Traitormod.Config.ChatMessageType, client)
end

-- set character traitor to enable sabotage, set mission objective text then sync with session
Traitormod.UpdateVanillaTraitor = function (client, enabled, objectiveSummary, missionIdentifier)
    if not client or not client.Character then
        Traitormod.Error("UpdateVanillaTraitor failed! Client or Character was null!")
        return
    end

    client.Character.IsTraitor = enabled
    client.Character.TraitorCurrentObjective = objectiveSummary
    Game.SendTraitorMessage(client, objectiveSummary, missionIdentifier or Traitormod.MissionIdentifier, TraitorMessageType.Objective)
end

-- send feedback to the character for completing a traitor objective and update vanilla traitor state
Traitormod.SendObjectiveCompleted = function(client, objectiveText, points, livesText)
    if livesText then
        livesText = "\n" .. livesText
    else
        livesText = ""
    end

    Traitormod.SendMessage(client, 
    string.format(Traitormod.Language.ObjectiveCompleted, objectiveText) .. " \n\n" .. 
    string.format(Traitormod.Language.PointsAwarded, points) .. livesText
    , "MissionCompletedIcon") --InfoFrameTabButton.Mission

    local role = Traitormod.RoleManager.GetRole(client.Character)

    if role then
        Traitormod.UpdateVanillaTraitor(client, true, role:Greet())
    end
end

Traitormod.SendObjectiveFailed = function(client, objectiveText)
    Traitormod.SendMessage(client, 
    string.format(Traitormod.Language.ObjectiveFailed, objectiveText), "MissionFailedIcon")

    local role = Traitormod.RoleManager.GetRole(client.Character)

    if role then
        Traitormod.UpdateVanillaTraitor(client, true, role:Greet())
    end
end

Traitormod.SelectCodeWords = function ()
    local copied = {}
    for key, value in pairs(Traitormod.Config.Codewords) do
        copied[key] = value
    end

    local selected = {}
    for i=1, Traitormod.Config.AmountCodeWords, 1 do
        table.insert(selected, copied[Random.Range(1, #copied + 1)])
    end

    local selected2 = {}
    for i=1, Traitormod.Config.AmountCodeWords, 1 do
        table.insert(selected2, copied[Random.Range(1, #copied + 1)])
    end

    return {selected, selected2}
end

Traitormod.ParseCommand = function (text)
    local result = {}

    if text == nil then return result end

    local spat, epat, buf, quoted = [=[^(["])]=], [=[(["])$]=]
    for str in text:gmatch("%S+") do
        local squoted = str:match(spat)
        local equoted = str:match(epat)
        local escaped = str:match([=[(\*)["]$]=])
        if squoted and not quoted and not equoted then
            buf, quoted = str, squoted
        elseif buf and equoted == quoted and #escaped % 2 == 0 then
            str, buf, quoted = buf .. ' ' .. str, nil, nil
        elseif buf then
            buf = buf .. ' ' .. str
        end
        if not buf then result[#result + 1] = str:gsub(spat,""):gsub(epat,"") end
    end

    return result
end

Traitormod.AddCommand = function (commandName, callback)
    if type(commandName) == "table" then
        for command in commandName do
            Traitormod.AddCommand(command, callback)
        end
    else
        local cmd = {}
    
        Traitormod.Commands[string.lower(commandName)] = cmd
        cmd.Callback = callback;
    end
end

Traitormod.RemoveCommand = function (commandName)
    Traitormod.Commands[commandName] = nil
end

-- type: 6 = Server message, 7 = Console usage, 9 error
Traitormod.Log = function (message)
    Game.Log("[TraitorMod] " .. message, 6)
end

Traitormod.Debug = function (message)
    if Traitormod.Config.DebugLogs then
        Game.Log("[TraitorMod-Debug] " .. message, 6)
    end
end

Traitormod.Error = function (message)
    Game.Log("[TraitorMod-Error] " .. message, 9)
    
    if Traitormod.Config.DebugLogs then
        printerror(message)
    end
end

Traitormod.AllCrewMissionsCompleted = function (missions)
    if not missions then
        if Game.GameSession == nil or Game.GameSession.Missions == nil then return end
        missions = Game.GameSession.Missions
    end
    for key, value in pairs(missions) do
        if not value.Completed then
            return false
        end
    end
    return true
end

Traitormod.LoadExperience = function (client)
    if client == nil then
        Traitormod.Error("Loading experience failed! Client was nil")
        return
    elseif not client.Character or not client.Character.Info then 
        Traitormod.Error("Loading experience failed! Client.Character or .Info was null! " .. Traitormod.ClientLogName(client))
        return 
    end
    local amount = Traitormod.Config.AmountExperienceWithPoints(Traitormod.GetData(client, "Points") or 0)
    local max = Traitormod.Config.MaxExperienceFromPoints or 2000000000     -- must be int32

    if amount > max then
        amount = max
    end

    Traitormod.Debug("Loading experience from stored points: " .. Traitormod.ClientLogName(client) .. " -> " .. amount)
    client.Character.Info.SetExperience(amount)
end

Traitormod.GiveExperience = function (character, amount, isMissionXP)
    if character == nil or character.Info == nil or character.Info.GiveExperience == nil or character.IsHuman == false or amount == nil or amount == 0 then
        return false
    end
    Traitormod.Debug("Giving experience to character: " .. character.Name .. " -> " .. amount)
    character.Info.GiveExperience(amount, isMissionXP)
    return true
end

Traitormod.AwardPoints = function (client, amount, isMissionXP)
    if not Traitormod.Config.TestMode then
        Traitormod.AddData(client, "Points", amount)
        Traitormod.Stats.AddClientStat("PointsGained", client, amount)
        Traitormod.Log(string.format("Client %s was awarded %d points.", Traitormod.ClientLogName(client), math.floor(amount)))
        if Traitormod.SelectedGamemode and Traitormod.SelectedGamemode.AwardedPoints then
            local oldValue = Traitormod.SelectedGamemode.AwardedPoints[client.SteamID] or 0
            Traitormod.SelectedGamemode.AwardedPoints[client.SteamID] = oldValue + amount
        end
    end
    return amount
end

Traitormod.AdjustLives = function (client, amount)
    if not amount or amount == 0 then
        return
    end

    local oldLives = Traitormod.GetData(client, "Lives") or Traitormod.Config.MaxLives
    local newLives =  oldLives + amount

    if (newLives or 0) > Traitormod.Config.MaxLives then
        -- if gained more lives than maxLives, reset to maxLives
        newLives = Traitormod.Config.MaxLives
    end

    local icon = "InfoFrameTabButton.Mission"
    if newLives == oldLives then
        -- no change in lives, no need for feedback
        return nil, icon
    end

    local amountString = Traitormod.Language.ALife
    if amount > 1 then amountString = amount .. Traitormod.Language.Lives end

    local lifeAdjustMessage = string.format(Traitormod.Language.LivesGained, amountString, newLives, Traitormod.Config.MaxLives)
    if amount < 0 then
        icon = "GameModeIcon.pvp"
        local newLivesString = Traitormod.Language.ALife
        if newLives > 1 then
            newLivesString = newLives .. Traitormod.Language.Lives
        end
        lifeAdjustMessage = string.format(Traitormod.Language.Death, newLivesString)
    end

    if (newLives or 0) <= 0 then
        -- if no lives left, reduce amount of points, reset to maxLives
        Traitormod.Log("Player ".. client.Name .." lost all lives. Reducing points...")
        if not Traitormod.Config.TestMode then  
            local oldAmount = Traitormod.GetData(client, "Points") or 0
            local newAmount = Traitormod.Config.PointsLostAfterNoLives(oldAmount)
            Traitormod.SetData(client, "Points", newAmount)
            Traitormod.Stats.AddClientStat("PointsLost", client, oldAmount - newAmount)

            Traitormod.LoadExperience(client)
        end
        newLives = Traitormod.Config.MaxLives
        lifeAdjustMessage = string.format(Traitormod.Language.NoLives, newLives)
    end
    
    Traitormod.Log("Adjusting lives of player " .. Traitormod.ClientLogName(client) .. " by " .. amount .. ". New value: " .. newLives)
    Traitormod.SetData(client, "Lives", newLives)
    return lifeAdjustMessage, icon
end

Traitormod.SendTip = function ()
    local tip = Traitormod.Language.Tips[math.random(1, #Traitormod.Language.Tips)]

    for index, value in pairs(Client.ClientList) do
        Traitormod.SendChatMessage(value, Traitormod.Language.TipText .. tip, Color.Orange)
    end
end

Traitormod.GetDataInfo = function(client, showWeights)
    local weightInfo = ""
    if showWeights then
        local maxPoints = 0
        for index, value in pairs(Client.ClientList) do
            maxPoints = maxPoints + (Traitormod.GetData(value, "Weight") or 0)
        end
    
        local percentage = (Traitormod.GetData(client, "Weight") or 0) / maxPoints * 100
    
        if percentage ~= percentage then
            percentage = 100 -- percentage is NaN, set it to 100%
        end

        weightInfo = "\n\n" .. string.format(Traitormod.Language.TraitorInfo, math.floor(percentage))
    end

    return string.format(Traitormod.Language.PointsInfo, math.floor(Traitormod.GetData(client, "Points") or 0), Traitormod.GetData(client, "Lives") or Traitormod.Config.MaxLives, Traitormod.Config.MaxLives) .. weightInfo
end

Traitormod.ClientLogName = function(client, name)
    if name == nil then name = client.Name end

    name = string.gsub(name, "%‖", "")

    local log = "‖metadata:" .. client.SteamID .. "‖" .. name .. "‖end‖"
    return log
end

Traitormod.InsertString = function(str1, str2, pos)
    return str1:sub(1,pos)..str2..str1:sub(pos+1)
end

Traitormod.HighlightClientNames = function (text, color)
    for key, value in pairs(Client.ClientList) do
        local name = value.Name

        local i, j = string.find(text, name)

        if i ~= nil then
            text = Traitormod.InsertString(text, string.format("‖color:%s,%s,%s‖", color.R, color.G, color.B), i - 1)
        end

        local i, j = string.find(text, name)

        if i ~= nil then
            text = Traitormod.InsertString(text, "‖end‖", j)
        end
    end

    return text
end

Traitormod.GetJobString = function(character)
    local prefix = "Crew member"
    if character.Info and character.Info.Job then
        prefix = tostring(TextManager.Get("jobname." .. tostring(character.Info.Job.Prefab.Identifier)))
    end
    return prefix
end

-- returns true if character has reached the end of the level
Traitormod.EndReached = function(character, distance)
    if LevelData and LevelData.LevelType and LevelData.LevelType.Outpost then
        return true
    end

    if Level.Loaded.EndOutpost == nil then
        return Submarine.MainSub.AtEndExit
    end

    local characterInsideOutpost = not character.IsDead and character.Submarine == Level.Loaded.EndOutpost
    -- character is inside or docked to outpost 
    return characterInsideOutpost or Vector2.Distance(character.WorldPosition, Level.Loaded.EndPosition) < distance
end

Traitormod.SendWelcome = function(client)
    if Traitormod.Config.SendWelcomeMessage or Traitormod.Config.SendWelcomeMessage == nil then
        Game.SendDirectChatMessage("Type !help for a list of commands.", "| Prison Traitor Mod v" .. Traitormod.VERSION .. " |\n" .. Traitormod.GetDataInfo(client), nil, ChatMessageType.Server, client)
    end
endlocal objective = Traitormod.RoleManager.Objectives.Objective:new()

objective.Name = "TurnHusk"
objective.AmountPoints = 500
objective.AmountLives = 1
objective.AlwaysActive = true
objective.DontLooseLives = true

function objective:Start()
    self.Text = "Turn yourself into a husk."

    self.OldCharacter = self.Character

    return true
end

function objective:IsCompleted()
    if self.OldCharacter == nil then
        return
    end

    local aff = self.OldCharacter.CharacterHealth.GetAffliction("huskinfection", true)

    if aff ~= nil and aff.Strength > 95 then
        return true
    end

    return false
end

return objective
local vt = {}

local textPromptUtils = require("textpromptutils")

vt.Votes = {}

vt.StartVote = function (text, options, time, completed)
    local voteData = {}

    table.insert(vt.Votes, voteData)

    local voteId = #vt.Votes

    voteData.Time = Timer.GetTime() + time
    voteData.OnCompleted = completed
    voteData.Results = {}
    for i = 1, #options, 1 do
        voteData.Results[i] = 0
    end

    local max = 0
    local amount = 0

    for key, client1 in pairs(Client.ClientList) do
        max = max + 1
        textPromptUtils.Prompt(text, options, client1, function (id, client2)
            if voteData.Completed then return end

            local option = options[id]

            if option == nil then return end
            
            voteData.Results[id] = voteData.Results[id] + 1

            amount = amount + 1

            if amount == max then
                voteData.OnCompleted(voteData.Results)
                voteData.Completed = true
                table.remove(vt.Votes, voteId)
            end
        end)
    end
end

Hook.Add("think", "Traitormod.Voting.Think", function ()
    for key, voteData in pairs(vt.Votes) do
        if Timer.GetTime() > voteData.Time then
            voteData.OnCompleted(voteData.Results)
            voteData.Completed = true
            table.remove(vt.Votes, key)
            break
        end
    end
end)

Traitormod.AddCommand("!vote", function (client, args)
    if not client.HasPermission(ClientPermissions.ConsoleCommands) then return end
    if not client.InGame then
        Traitormod.SendMessage(client, "You must be in game to use this command.")
        return true
    end

    if #args < 3 then
        Traitormod.SendMessage(client, "Usage: !vote \"Text Here\" \"Option 1\" \"Option 2\" ... \"Option N\"")
        return true
    end

    local text = table.remove(args, 1)

    vt.StartVote(text, args, 25, function (results)
        local message = Traitormod.StringBuilder:new()
        message("Vote results: %s\n\n", text)
        for key, value in pairs(results) do
            message("%s: %s Votes\n", args[key], value)
        end

        for key, target in pairs(Client.ClientList) do
            local chatMessage = ChatMessage.Create("", message:concat(), ChatMessageType.Default, nil, nil)
            chatMessage.Color = Color(255, 255, 255, 255)
            Game.SendDirectChatMessage(chatMessage, target)
        end
    end)

    return true
end)

return vtlocal weightedRandom = {}

local function Depth0(subjects)
    local total = 0
    for key, value in pairs(subjects) do
        total = total + value
    end

    local rng = Random.Range(0, total)

    local step = 0
    for key, value in pairs(subjects) do
        step = step + value

        if rng > step - value and rng < step then
            return key
        end
    end
end

local function Depth1(subjects, variable)
    local total = 0
    for key, value in pairs(subjects) do
        total = total + value[variable]
    end

    local rng = Random.Range(0, total)

    local step = 0
    for key, value in pairs(subjects) do
        step = step + value[variable]

        if rng > step - value[variable] and rng < step then
            return key
        end
    end
end

local function Depth2(subjects, variable, subVariable)
    local total = 0
    for key, value in pairs(subjects) do
        total = total + value[variable][subVariable]
    end

    local rng = Random.Range(0, total)

    local step = 0
    for key, value in pairs(subjects) do
        step = step + value[variable][subVariable]

        if rng > step - value[variable][subVariable] and rng < step then
            return key
        end
    end
end

weightedRandom.Choose = function (subjects, variable, subVariable)

    local res = nil
    if variable == nil then 
        res = Depth0(subjects) 
    elseif variable ~= nil and subVariable ~= nil then 
        res = Depth2(subjects, variable, subVariable)
    elseif variable ~= nil then 
        res = Depth1(subjects, variable) 
    end

    if res == nil then
        for key, value in pairs(subjects) do
            return key
        end
    else
        return res
    end
end

return weightedRandomlocal event = {}

event.Name = "WreckPirate"
event.MinRoundTime = 1
event.MaxRoundTime = 15
event.MinIntensity = 0
event.MaxIntensity = 1
event.ChancePerMinute = 0.15
event.OnlyOncePerRound = true

event.AmountPoints = 800
event.AmountPointsPirate = 500

event.Start = function ()
    if #Level.Loaded.Wrecks == 0 then
        return
    end

    local wreck = Level.Loaded.Wrecks[1]

    local info = CharacterInfo(Identifier("human"))
    info.Name = "Pirate " .. info.Name
    info.Job = Job(JobPrefab.Get("warden"))

    local character = Character.Create(info, wreck.WorldPosition, info.Name, 0, false, true)

    event.Character = character
    event.Wreck = wreck
    event.EnteredMainSub = false

    character.CanSpeak = true
    character.TeamID = CharacterTeamType.Team2
    character.GiveJobItems(nil)

    local idCard = character.Inventory.GetItemInLimbSlot(InvSlotType.Card)
    if idCard then
        idCard.NonPlayerTeamInteractable = true
        local prop = idCard.SerializableProperties[Identifier("NonPlayerTeamInteractable")]
        Networking.CreateEntityEvent(idCard, Item.ChangePropertyEventData(prop, idCard))
    end

    local headset = character.Inventory.GetItemInLimbSlot(InvSlotType.Headset)
    if headset then
       local wifi = headset.GetComponentString("WifiComponent")
       if wifi then
            wifi.TeamID = CharacterTeamType.FriendlyNPC
       end
    end

    Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.Prefabs["sonarbeacon"], wreck.WorldPosition, nil, nil, function(item)
        item.NonInteractable = true

        Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.Prefabs["batterycell"], item.OwnInventory, nil, nil, function(bat)
            bat.Indestructible = true

            local interface = item.GetComponentString("CustomInterface")

            interface.customInterfaceElementList[1].State = true
            interface.customInterfaceElementList[2].Signal = "Last known pirate position"

            item.CreateServerEvent(interface, interface)
        end)
    end)

    Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("shotgun"), character.Inventory, nil, nil, function (item)
        for i = 1, 6, 1 do
            Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("shotgunshell"), item.OwnInventory)
        end
    end)

    Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("smg"), character.Inventory, nil, nil, function (item)
        Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("smgmagazinedepletedfuel"), item.OwnInventory)
    end)

    Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("smgmagazine"), character.Inventory)
    Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("smgmagazine"), character.Inventory)
    Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("antiparalysis"), character.Inventory)
    Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("antiparalysis"), character.Inventory)
    Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("oxygenitetank"), character.Inventory)
    Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("oxygenitetank"), character.Inventory)
    Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("oxygenitetank"), character.Inventory)
    Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("oxygenitetank"), character.Inventory)

    for i = 1, 12, 1 do
        Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("shotgunshell"), character.Inventory)
    end

    for i = 1, 4, 1 do
        Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("antibiotics"), character.Inventory)
    end
    local toolbelt = character.Inventory.GetItemInLimbSlot(InvSlotType.Bag)
    Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("antidama1"), toolbelt.OwnInventory)
    Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("antidama1"), toolbelt.OwnInventory)
    for i = 1, 6, 1 do
        Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("antibleeding1"), toolbelt.OwnInventory)
    end
    Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("alienblood"), toolbelt.OwnInventory)
    Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("fuelrod"), toolbelt.OwnInventory)
    Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("underwaterscooter"), toolbelt.OwnInventory, nil, nil, function (item)
        Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("batterycell"), item.OwnInventory)
    end)
    Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("handheldsonar"), toolbelt.OwnInventory, nil, nil, function (item)
        Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("batterycell"), item.OwnInventory)
    end)

    local oldClothes = character.Inventory.GetItemInLimbSlot(InvSlotType.InnerClothes)
    oldClothes.Drop()
    Entity.Spawner.AddEntityToRemoveQueue(oldClothes)

    Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("pirateclothes"), character.Inventory, nil, nil, function (item)
        character.Inventory.TryPutItem(item, character.Inventory.FindLimbSlot(InvSlotType.InnerClothes), true, false, character)
    end)

    Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("pucs"), character.Inventory, nil, nil, function (item)
        Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("combatstimulantsyringe"), item.OwnInventory)
        Entity.Spawner.AddItemToSpawnQueue(ItemPrefab.GetItemPrefab("oxygenitetank"), item.OwnInventory)
    end)

    local text = "There have been reports about a notorious pirate with a PUCS suit terrorizing these waters, the pirate was detected recently inside a wrecked submarine - eliminate the pirate to claim a reward of " .. event.AmountPoints .. " points for the entire crew."
    Traitormod.RoundEvents.SendEventMessage(text, "CrewWalletIconLarge")

    Traitormod.GhostRoles.Ask("Wreck Pirate", function (client)
        Traitormod.LostLivesThisRound[client.SteamID] = false
        client.SetClientCharacter(character)

        Traitormod.SendMessageCharacter(character, "You are a pirate! Protect the wreck from any filthy coalitions, it will be eventually home to our center of operations! \n\nSurviving inside the wreck until the end of the round will grant you " .. event.AmountPointsPirate .." points.", "InfoFrameTabButton.Mission")
    end, character)

    Hook.Add("think", "WreckPirate.Think", function ()
        if character.IsDead then
            event.End()
        end

        if character.Submarine == Submarine.MainSub and not event.EnteredMainSub then
            event.EnteredMainSub = true
            Traitormod.RoundEvents.SendEventMessage("Attention! A dangerous PUCS pirate has been detected inside the main submarine!")
        end
    end)
end


event.End = function (isEndRound)
    Hook.Remove("think", "WreckPirate.Think")

    if isEndRound then
        if event.Character and not event.Character.IsDead and event.Character.Submarine == event.Wreck then
            local client = Traitormod.FindClientCharacter(event.Character)
            if client then
                Traitormod.AwardPoints(client, event.AmountPointsPirate)
                Traitormod.SendMessage(client, "You have received " .. event.AmountPointsPirate .. " points.", "InfoFrameTabButton.Mission")
            end
        end

        return
    end

    local text = "The PUCS pirate has been killed, the crew has received a reward of " .. event.AmountPoints .. " points."

    Traitormod.RoundEvents.SendEventMessage(text, "CrewWalletIconLarge")

    for _, client in pairs(Client.ClientList) do
        if client.Character and not client.Character.IsDead and client.Character.TeamID == CharacterTeamType.FriendlyNPC then
            Traitormod.AwardPoints(client, event.AmountPoints)
            Traitormod.SendMessage(client, "You have received " .. event.AmountPoints .. " points.", "InfoFrameTabButton.Mission")
        end
    end
end

return eventlocal path = ...

local m = {}

local function ReplaceModDir(str)
    return str:gsub("%%ModDir%%", path)
end

m.RemoveAll = function (root, name)
    while (true) do
        local element = root.Element(name) or root.Element(string.lower(name))
        if element == nil then break end
        element.Remove()
    end
end

m.Add = function (root, xml)
    xml = XDocument.Parse(ReplaceModDir(xml))

    for element in xml.Root.Elements() do
        root.Add(element)
    end
end

m.ReplaceWithOwnPath = function (element)
    local file = element.Attribute("originalfile") or element.Attribute("file")
    file = file.Value
    element.SetAttributeValue("originalfile", file)
    element.SetAttributeValue("file", path .. "/" .. file)
end

m.Replace = function (element, arg1, arg2)
    if arg2 == nil then
        arg2 = arg1
        arg1 = "file"
    end

    if arg1 == "file" then
        arg2 = path .. "/" .. arg2
    end

    element.SetAttributeValue(arg1, arg2)
end

return m
